/**
 * @file mcb.h
 *
 * @brief This header file was generated by cantools version 40.5.0 Sat Sep 13 16:02:03 2025.
 *
 * @copyright Copyright (c) 2018-2019 Erik Moqvist
 *
 * @par License
 * The MIT License (MIT)
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

#ifndef MCB_H
#define MCB_H

#ifdef __cplusplus
extern "C" {
#endif

#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>

#ifndef EINVAL
#    define EINVAL 22
#endif

/* Frame ids. */
#define MCB_IRTS_PLACEHOLDER_MESSAGE_FRAME_ID (0x708u)
#define MCB_SB_FRONT_ANALOG_DEVICE_FRAME_ID (0x52u)
#define MCB_SB_FRONT_SD_CSENSING_STATUS_FRAME_ID (0x302u)
#define MCB_SB_FRONT_POTENTIOMETER_FRAME_ID (0x322u)
#define MCB_SB_FRONT_XCP_TX_FRAME_ID (0x462u)
#define MCB_SB_FRONT_HELLO_FRAME_ID (0x642u)
#define MCB_SB_FRONT_NTC_RESISTANCE_FRAME_ID (0x672u)
#define MCB_SB_REAR_ANALOG_DEVICE_FRAME_ID (0x63u)
#define MCB_SB_REAR_CRITICAL_PERIPHERALS_FRAME_ID (0x73u)
#define MCB_SB_REAR_SD_CSENSING_STATUS_FRAME_ID (0x2f3u)
#define MCB_SB_REAR_POTENTIOMETER_FRAME_ID (0x333u)
#define MCB_SB_REAR_XCP_TX_FRAME_ID (0x463u)
#define MCB_SB_REAR_HELLO_FRAME_ID (0x643u)
#define MCB_SB_REAR_NTC_RESISTANCE_FRAME_ID (0x683u)
#define MCB_TLB_BAT_SIGNALS_STATUS_FRAME_ID (0x41u)
#define MCB_TLB_BAT_SD_CSENSING_STATUS_FRAME_ID (0x2e1u)
#define MCB_TLB_BAT_XCP_TX_FRAME_ID (0x461u)
#define MCB_TLB_BAT_HELLO_FRAME_ID (0x641u)
#define MCB_IMU_ACCELEROMETERS_FRAME_ID (0x37bu)
#define MCB_IMU_GYRO_FRAME_ID (0x38bu)
#define MCB_IMU_EULER_FRAME_ID (0x39bu)
#define MCB_IMU_GPS1_POSITION_FRAME_ID (0x3abu)
#define MCB_IMU_VELOCITY_BODY_FRAME_ID (0x3bbu)
#define MCB_IMU_TRACK_SLIP_CURV_FRAME_ID (0x3cbu)
#define MCB_TPMS_FRONT_WHEELS_PRESSURE_FRAME_ID (0x50au)
#define MCB_TPMS_REAR_WHEELS_PRESSURE_FRAME_ID (0x51au)
#define MCB_NLG5_ST_FRAME_ID (0x610u)
#define MCB_NLG5_ACT_I_FRAME_ID (0x611u)
#define MCB_NLG5_ACT_II_FRAME_ID (0x612u)
#define MCB_NLG5_TEMP_FRAME_ID (0x613u)
#define MCB_NLG5_ERR_FRAME_ID (0x614u)
#define MCB_NLG5_CTL_FRAME_ID (0x618u)
#define MCB_NLG5_DIAG_RX_FRAME_ID (0x718u)
#define MCB_NLG5_DIAG_TX_FRAME_ID (0x71au)
#define MCB_BMS_LV_LV_BAT_GENERAL_FRAME_ID (0x144u)
#define MCB_BMS_LV_XCP_TX_FRAME_ID (0x464u)
#define MCB_BMS_LV_CELLS_STATUS_FRAME_ID (0x4b4u)
#define MCB_BMS_LV_STATUS_FRAME_ID (0x4c4u)
#define MCB_BMS_LV_LV_CELL_VOLTAGE0_FRAME_ID (0x4d4u)
#define MCB_BMS_LV_LV_CELL_VOLTAGE1_FRAME_ID (0x4e4u)
#define MCB_BMS_LV_HELLO_FRAME_ID (0x644u)
#define MCB_BMS_LV_LV_CELL_NTC_RESISTANCE0_FRAME_ID (0x654u)
#define MCB_BMS_LV_LV_CELL_NTC_RESISTANCE1_FRAME_ID (0x664u)
#define MCB_DASH_HMI_DEVICES_STATE_FRAME_ID (0x165u)
#define MCB_DASH_XCP_TX_FRAME_ID (0x465u)
#define MCB_DASH_PERIPHERALS_STATUS_FRAME_ID (0x4f5u)
#define MCB_DASH_HELLO_FRAME_ID (0x645u)
#define MCB_DASH_APPS_RANGE_LIMITS_FRAME_ID (0x695u)
#define MCB_DASH_CAR_COMMANDS_FRAME_ID (0x6a5u)
#define MCB_DIAG_TOOL_XCP_TX_BMS_LV_FRAME_ID (0x286u)
#define MCB_DIAG_TOOL_XCP_TX_DASH_FRAME_ID (0x296u)
#define MCB_DIAG_TOOL_XCP_TX_SB_REAR_FRAME_ID (0x2a6u)
#define MCB_DIAG_TOOL_XCP_TX_SB_FRONT_FRAME_ID (0x2b6u)
#define MCB_DIAG_TOOL_XCP_TX_SCANNER_FRAME_ID (0x2c6u)
#define MCB_DIAG_TOOL_XCP_TX_TLB_BAT_FRAME_ID (0x2d6u)
#define MCB_DSPACE_TIME_AND_DATE_FRAME_ID (0x17u)
#define MCB_DSPACE_PERIPHERALS_CTRL_FRAME_ID (0x197u)
#define MCB_DSPACE_PWT_FRONT_TEMP_FRAME_ID (0x1b7u)
#define MCB_DSPACE_PWT_REAR_TEMP_FRAME_ID (0x1c7u)
#define MCB_DSPACE_XCP_TX_FRAME_ID (0x467u)
#define MCB_DSPACE_SIGNALS_FRAME_ID (0x497u)
#define MCB_DSPACE_FSM_STATES_FRAME_ID (0x4a7u)
#define MCB_DSPACE_HELLO_FRAME_ID (0x647u)
#define MCB_DSPACE_DASH_LEDS_COLOR_RGB_FRAME_ID (0x6b7u)
#define MCB_SCANNER_XCP_TX_FRAME_ID (0x469u)

/* Frame lengths in bytes. */
#define MCB_IRTS_PLACEHOLDER_MESSAGE_LENGTH (8u)
#define MCB_SB_FRONT_ANALOG_DEVICE_LENGTH (8u)
#define MCB_SB_FRONT_SD_CSENSING_STATUS_LENGTH (1u)
#define MCB_SB_FRONT_POTENTIOMETER_LENGTH (4u)
#define MCB_SB_FRONT_XCP_TX_LENGTH (8u)
#define MCB_SB_FRONT_HELLO_LENGTH (3u)
#define MCB_SB_FRONT_NTC_RESISTANCE_LENGTH (8u)
#define MCB_SB_REAR_ANALOG_DEVICE_LENGTH (6u)
#define MCB_SB_REAR_CRITICAL_PERIPHERALS_LENGTH (1u)
#define MCB_SB_REAR_SD_CSENSING_STATUS_LENGTH (1u)
#define MCB_SB_REAR_POTENTIOMETER_LENGTH (4u)
#define MCB_SB_REAR_XCP_TX_LENGTH (8u)
#define MCB_SB_REAR_HELLO_LENGTH (3u)
#define MCB_SB_REAR_NTC_RESISTANCE_LENGTH (8u)
#define MCB_TLB_BAT_SIGNALS_STATUS_LENGTH (4u)
#define MCB_TLB_BAT_SD_CSENSING_STATUS_LENGTH (3u)
#define MCB_TLB_BAT_XCP_TX_LENGTH (8u)
#define MCB_TLB_BAT_HELLO_LENGTH (3u)
#define MCB_IMU_ACCELEROMETERS_LENGTH (6u)
#define MCB_IMU_GYRO_LENGTH (6u)
#define MCB_IMU_EULER_LENGTH (6u)
#define MCB_IMU_GPS1_POSITION_LENGTH (8u)
#define MCB_IMU_VELOCITY_BODY_LENGTH (6u)
#define MCB_IMU_TRACK_SLIP_CURV_LENGTH (7u)
#define MCB_TPMS_FRONT_WHEELS_PRESSURE_LENGTH (8u)
#define MCB_TPMS_REAR_WHEELS_PRESSURE_LENGTH (8u)
#define MCB_NLG5_ST_LENGTH (4u)
#define MCB_NLG5_ACT_I_LENGTH (8u)
#define MCB_NLG5_ACT_II_LENGTH (8u)
#define MCB_NLG5_TEMP_LENGTH (8u)
#define MCB_NLG5_ERR_LENGTH (5u)
#define MCB_NLG5_CTL_LENGTH (7u)
#define MCB_NLG5_DIAG_RX_LENGTH (8u)
#define MCB_NLG5_DIAG_TX_LENGTH (8u)
#define MCB_BMS_LV_LV_BAT_GENERAL_LENGTH (6u)
#define MCB_BMS_LV_XCP_TX_LENGTH (8u)
#define MCB_BMS_LV_CELLS_STATUS_LENGTH (5u)
#define MCB_BMS_LV_STATUS_LENGTH (1u)
#define MCB_BMS_LV_LV_CELL_VOLTAGE0_LENGTH (8u)
#define MCB_BMS_LV_LV_CELL_VOLTAGE1_LENGTH (6u)
#define MCB_BMS_LV_HELLO_LENGTH (3u)
#define MCB_BMS_LV_LV_CELL_NTC_RESISTANCE0_LENGTH (8u)
#define MCB_BMS_LV_LV_CELL_NTC_RESISTANCE1_LENGTH (8u)
#define MCB_DASH_HMI_DEVICES_STATE_LENGTH (3u)
#define MCB_DASH_XCP_TX_LENGTH (8u)
#define MCB_DASH_PERIPHERALS_STATUS_LENGTH (1u)
#define MCB_DASH_HELLO_LENGTH (3u)
#define MCB_DASH_APPS_RANGE_LIMITS_LENGTH (8u)
#define MCB_DASH_CAR_COMMANDS_LENGTH (3u)
#define MCB_DIAG_TOOL_XCP_TX_BMS_LV_LENGTH (8u)
#define MCB_DIAG_TOOL_XCP_TX_DASH_LENGTH (8u)
#define MCB_DIAG_TOOL_XCP_TX_SB_REAR_LENGTH (8u)
#define MCB_DIAG_TOOL_XCP_TX_SB_FRONT_LENGTH (8u)
#define MCB_DIAG_TOOL_XCP_TX_SCANNER_LENGTH (8u)
#define MCB_DIAG_TOOL_XCP_TX_TLB_BAT_LENGTH (8u)
#define MCB_DSPACE_TIME_AND_DATE_LENGTH (6u)
#define MCB_DSPACE_PERIPHERALS_CTRL_LENGTH (3u)
#define MCB_DSPACE_PWT_FRONT_TEMP_LENGTH (8u)
#define MCB_DSPACE_PWT_REAR_TEMP_LENGTH (8u)
#define MCB_DSPACE_XCP_TX_LENGTH (8u)
#define MCB_DSPACE_SIGNALS_LENGTH (1u)
#define MCB_DSPACE_FSM_STATES_LENGTH (5u)
#define MCB_DSPACE_HELLO_LENGTH (3u)
#define MCB_DSPACE_DASH_LEDS_COLOR_RGB_LENGTH (5u)
#define MCB_SCANNER_XCP_TX_LENGTH (8u)

/* Extended or standard frame types. */
#define MCB_IRTS_PLACEHOLDER_MESSAGE_IS_EXTENDED (0)
#define MCB_SB_FRONT_ANALOG_DEVICE_IS_EXTENDED (0)
#define MCB_SB_FRONT_SD_CSENSING_STATUS_IS_EXTENDED (0)
#define MCB_SB_FRONT_POTENTIOMETER_IS_EXTENDED (0)
#define MCB_SB_FRONT_XCP_TX_IS_EXTENDED (0)
#define MCB_SB_FRONT_HELLO_IS_EXTENDED (0)
#define MCB_SB_FRONT_NTC_RESISTANCE_IS_EXTENDED (0)
#define MCB_SB_REAR_ANALOG_DEVICE_IS_EXTENDED (0)
#define MCB_SB_REAR_CRITICAL_PERIPHERALS_IS_EXTENDED (0)
#define MCB_SB_REAR_SD_CSENSING_STATUS_IS_EXTENDED (0)
#define MCB_SB_REAR_POTENTIOMETER_IS_EXTENDED (0)
#define MCB_SB_REAR_XCP_TX_IS_EXTENDED (0)
#define MCB_SB_REAR_HELLO_IS_EXTENDED (0)
#define MCB_SB_REAR_NTC_RESISTANCE_IS_EXTENDED (0)
#define MCB_TLB_BAT_SIGNALS_STATUS_IS_EXTENDED (0)
#define MCB_TLB_BAT_SD_CSENSING_STATUS_IS_EXTENDED (0)
#define MCB_TLB_BAT_XCP_TX_IS_EXTENDED (0)
#define MCB_TLB_BAT_HELLO_IS_EXTENDED (0)
#define MCB_IMU_ACCELEROMETERS_IS_EXTENDED (0)
#define MCB_IMU_GYRO_IS_EXTENDED (0)
#define MCB_IMU_EULER_IS_EXTENDED (0)
#define MCB_IMU_GPS1_POSITION_IS_EXTENDED (0)
#define MCB_IMU_VELOCITY_BODY_IS_EXTENDED (0)
#define MCB_IMU_TRACK_SLIP_CURV_IS_EXTENDED (0)
#define MCB_TPMS_FRONT_WHEELS_PRESSURE_IS_EXTENDED (0)
#define MCB_TPMS_REAR_WHEELS_PRESSURE_IS_EXTENDED (0)
#define MCB_NLG5_ST_IS_EXTENDED (0)
#define MCB_NLG5_ACT_I_IS_EXTENDED (0)
#define MCB_NLG5_ACT_II_IS_EXTENDED (0)
#define MCB_NLG5_TEMP_IS_EXTENDED (0)
#define MCB_NLG5_ERR_IS_EXTENDED (0)
#define MCB_NLG5_CTL_IS_EXTENDED (0)
#define MCB_NLG5_DIAG_RX_IS_EXTENDED (0)
#define MCB_NLG5_DIAG_TX_IS_EXTENDED (0)
#define MCB_BMS_LV_LV_BAT_GENERAL_IS_EXTENDED (0)
#define MCB_BMS_LV_XCP_TX_IS_EXTENDED (0)
#define MCB_BMS_LV_CELLS_STATUS_IS_EXTENDED (0)
#define MCB_BMS_LV_STATUS_IS_EXTENDED (0)
#define MCB_BMS_LV_LV_CELL_VOLTAGE0_IS_EXTENDED (0)
#define MCB_BMS_LV_LV_CELL_VOLTAGE1_IS_EXTENDED (0)
#define MCB_BMS_LV_HELLO_IS_EXTENDED (0)
#define MCB_BMS_LV_LV_CELL_NTC_RESISTANCE0_IS_EXTENDED (0)
#define MCB_BMS_LV_LV_CELL_NTC_RESISTANCE1_IS_EXTENDED (0)
#define MCB_DASH_HMI_DEVICES_STATE_IS_EXTENDED (0)
#define MCB_DASH_XCP_TX_IS_EXTENDED (0)
#define MCB_DASH_PERIPHERALS_STATUS_IS_EXTENDED (0)
#define MCB_DASH_HELLO_IS_EXTENDED (0)
#define MCB_DASH_APPS_RANGE_LIMITS_IS_EXTENDED (0)
#define MCB_DASH_CAR_COMMANDS_IS_EXTENDED (0)
#define MCB_DIAG_TOOL_XCP_TX_BMS_LV_IS_EXTENDED (0)
#define MCB_DIAG_TOOL_XCP_TX_DASH_IS_EXTENDED (0)
#define MCB_DIAG_TOOL_XCP_TX_SB_REAR_IS_EXTENDED (0)
#define MCB_DIAG_TOOL_XCP_TX_SB_FRONT_IS_EXTENDED (0)
#define MCB_DIAG_TOOL_XCP_TX_SCANNER_IS_EXTENDED (0)
#define MCB_DIAG_TOOL_XCP_TX_TLB_BAT_IS_EXTENDED (0)
#define MCB_DSPACE_TIME_AND_DATE_IS_EXTENDED (0)
#define MCB_DSPACE_PERIPHERALS_CTRL_IS_EXTENDED (0)
#define MCB_DSPACE_PWT_FRONT_TEMP_IS_EXTENDED (0)
#define MCB_DSPACE_PWT_REAR_TEMP_IS_EXTENDED (0)
#define MCB_DSPACE_XCP_TX_IS_EXTENDED (0)
#define MCB_DSPACE_SIGNALS_IS_EXTENDED (0)
#define MCB_DSPACE_FSM_STATES_IS_EXTENDED (0)
#define MCB_DSPACE_HELLO_IS_EXTENDED (0)
#define MCB_DSPACE_DASH_LEDS_COLOR_RGB_IS_EXTENDED (0)
#define MCB_SCANNER_XCP_TX_IS_EXTENDED (0)

/* Frame cycle times in milliseconds. */
#define MCB_SB_FRONT_ANALOG_DEVICE_CYCLE_TIME_MS (10u)
#define MCB_SB_FRONT_SD_CSENSING_STATUS_CYCLE_TIME_MS (10u)
#define MCB_SB_FRONT_POTENTIOMETER_CYCLE_TIME_MS (10u)
#define MCB_SB_FRONT_NTC_RESISTANCE_CYCLE_TIME_MS (500u)
#define MCB_SB_REAR_ANALOG_DEVICE_CYCLE_TIME_MS (10u)
#define MCB_SB_REAR_CRITICAL_PERIPHERALS_CYCLE_TIME_MS (10u)
#define MCB_SB_REAR_SD_CSENSING_STATUS_CYCLE_TIME_MS (10u)
#define MCB_SB_REAR_POTENTIOMETER_CYCLE_TIME_MS (10u)
#define MCB_SB_REAR_NTC_RESISTANCE_CYCLE_TIME_MS (500u)
#define MCB_TLB_BAT_SIGNALS_STATUS_CYCLE_TIME_MS (10u)
#define MCB_TLB_BAT_SD_CSENSING_STATUS_CYCLE_TIME_MS (10u)
#define MCB_NLG5_ST_CYCLE_TIME_MS (100u)
#define MCB_NLG5_ACT_I_CYCLE_TIME_MS (100u)
#define MCB_NLG5_ACT_II_CYCLE_TIME_MS (100u)
#define MCB_NLG5_TEMP_CYCLE_TIME_MS (1000u)
#define MCB_NLG5_ERR_CYCLE_TIME_MS (1000u)
#define MCB_NLG5_CTL_CYCLE_TIME_MS (100u)
#define MCB_BMS_LV_LV_BAT_GENERAL_CYCLE_TIME_MS (100u)
#define MCB_BMS_LV_CELLS_STATUS_CYCLE_TIME_MS (100u)
#define MCB_BMS_LV_STATUS_CYCLE_TIME_MS (500u)
#define MCB_BMS_LV_LV_CELL_VOLTAGE0_CYCLE_TIME_MS (100u)
#define MCB_BMS_LV_LV_CELL_VOLTAGE1_CYCLE_TIME_MS (100u)
#define MCB_BMS_LV_LV_CELL_NTC_RESISTANCE0_CYCLE_TIME_MS (2000u)
#define MCB_BMS_LV_LV_CELL_NTC_RESISTANCE1_CYCLE_TIME_MS (2000u)
#define MCB_DASH_HMI_DEVICES_STATE_CYCLE_TIME_MS (200u)
#define MCB_DASH_PERIPHERALS_STATUS_CYCLE_TIME_MS (500u)
#define MCB_DSPACE_TIME_AND_DATE_CYCLE_TIME_MS (10u)
#define MCB_DSPACE_PERIPHERALS_CTRL_CYCLE_TIME_MS (10u)
#define MCB_DSPACE_PWT_FRONT_TEMP_CYCLE_TIME_MS (100u)
#define MCB_DSPACE_PWT_REAR_TEMP_CYCLE_TIME_MS (100u)
#define MCB_DSPACE_SIGNALS_CYCLE_TIME_MS (100u)
#define MCB_DSPACE_FSM_STATES_CYCLE_TIME_MS (100u)
#define MCB_DSPACE_DASH_LEDS_COLOR_RGB_CYCLE_TIME_MS (200u)

/* Signal choices. */
#define MCB_DASH_CAR_COMMANDS_LV_RELAY_OVERRIDE_STATE_LV_RLY_OVERRIDE_OFF_CHOICE (0u)
#define MCB_DASH_CAR_COMMANDS_LV_RELAY_OVERRIDE_STATE_LV_RLY_OVERRIDE_OPEN_CHOICE (1u)
#define MCB_DASH_CAR_COMMANDS_LV_RELAY_OVERRIDE_STATE_LV_RLY_OVERRIDE_CLOSED_CHOICE (2u)

#define MCB_DSPACE_FSM_STATES_DSPACE_MAIN_FSM_STATE_IDLE_CHOICE (0u)
#define MCB_DSPACE_FSM_STATES_DSPACE_MAIN_FSM_STATE_PRECHARGE_CHOICE (1u)
#define MCB_DSPACE_FSM_STATES_DSPACE_MAIN_FSM_STATE_TS_ON_CHOICE (2u)
#define MCB_DSPACE_FSM_STATES_DSPACE_MAIN_FSM_STATE_RTD_REQUEST_CHOICE (3u)
#define MCB_DSPACE_FSM_STATES_DSPACE_MAIN_FSM_STATE_RTD_CHOICE (4u)
#define MCB_DSPACE_FSM_STATES_DSPACE_MAIN_FSM_STATE_TS_OFF_CHOICE (5u)
#define MCB_DSPACE_FSM_STATES_DSPACE_MAIN_FSM_STATE_DISCHARGE_CHOICE (255u)

#define MCB_DSPACE_FSM_STATES_DSPACE_AMK_INV_FL_FSM_STATE_RESET_CHOICE (0u)
#define MCB_DSPACE_FSM_STATES_DSPACE_AMK_INV_FL_FSM_STATE_LV_ON__CHOICE (1u)
#define MCB_DSPACE_FSM_STATES_DSPACE_AMK_INV_FL_FSM_STATE_TS_ON_CHOICE (2u)
#define MCB_DSPACE_FSM_STATES_DSPACE_AMK_INV_FL_FSM_STATE_RTD_CHOICE (3u)
#define MCB_DSPACE_FSM_STATES_DSPACE_AMK_INV_FL_FSM_STATE_MOTOR_DRIVE_CHOICE (4u)
#define MCB_DSPACE_FSM_STATES_DSPACE_AMK_INV_FL_FSM_STATE_INTERM_ERROR_CHOICE (5u)
#define MCB_DSPACE_FSM_STATES_DSPACE_AMK_INV_FL_FSM_STATE_HARD_ERROR_CHOICE (6u)

#define MCB_DSPACE_FSM_STATES_DSPACE_AMK_INV_FR_FSM_STATE_RESET_CHOICE (0u)
#define MCB_DSPACE_FSM_STATES_DSPACE_AMK_INV_FR_FSM_STATE_LV_ON__CHOICE (1u)
#define MCB_DSPACE_FSM_STATES_DSPACE_AMK_INV_FR_FSM_STATE_TS_ON_CHOICE (2u)
#define MCB_DSPACE_FSM_STATES_DSPACE_AMK_INV_FR_FSM_STATE_RTD_CHOICE (3u)
#define MCB_DSPACE_FSM_STATES_DSPACE_AMK_INV_FR_FSM_STATE_MOTOR_DRIVE_CHOICE (4u)
#define MCB_DSPACE_FSM_STATES_DSPACE_AMK_INV_FR_FSM_STATE_INTERM_ERROR_CHOICE (5u)
#define MCB_DSPACE_FSM_STATES_DSPACE_AMK_INV_FR_FSM_STATE_HARD_ERROR_CHOICE (6u)

#define MCB_DSPACE_FSM_STATES_DSPACE_AMK_INV_RL_FSM_STATE_RESET_CHOICE (0u)
#define MCB_DSPACE_FSM_STATES_DSPACE_AMK_INV_RL_FSM_STATE_LV_ON__CHOICE (1u)
#define MCB_DSPACE_FSM_STATES_DSPACE_AMK_INV_RL_FSM_STATE_TS_ON_CHOICE (2u)
#define MCB_DSPACE_FSM_STATES_DSPACE_AMK_INV_RL_FSM_STATE_RTD_CHOICE (3u)
#define MCB_DSPACE_FSM_STATES_DSPACE_AMK_INV_RL_FSM_STATE_MOTOR_DRIVE_CHOICE (4u)
#define MCB_DSPACE_FSM_STATES_DSPACE_AMK_INV_RL_FSM_STATE_INTERM_ERROR_CHOICE (5u)
#define MCB_DSPACE_FSM_STATES_DSPACE_AMK_INV_RL_FSM_STATE_HARD_ERROR_CHOICE (6u)

#define MCB_DSPACE_FSM_STATES_DSPACE_AMK_INV_RR_FSM_STATE_RESET_CHOICE (0u)
#define MCB_DSPACE_FSM_STATES_DSPACE_AMK_INV_RR_FSM_STATE_LV_ON__CHOICE (1u)
#define MCB_DSPACE_FSM_STATES_DSPACE_AMK_INV_RR_FSM_STATE_TS_ON_CHOICE (2u)
#define MCB_DSPACE_FSM_STATES_DSPACE_AMK_INV_RR_FSM_STATE_RTD_CHOICE (3u)
#define MCB_DSPACE_FSM_STATES_DSPACE_AMK_INV_RR_FSM_STATE_MOTOR_DRIVE_CHOICE (4u)
#define MCB_DSPACE_FSM_STATES_DSPACE_AMK_INV_RR_FSM_STATE_INTERM_ERROR_CHOICE (5u)
#define MCB_DSPACE_FSM_STATES_DSPACE_AMK_INV_RR_FSM_STATE_HARD_ERROR_CHOICE (6u)

/* Frame Names. */
#define MCB_IRTS_PLACEHOLDER_MESSAGE_NAME "IRTS_placeholderMessage"
#define MCB_SB_FRONT_ANALOG_DEVICE_NAME "SB_FRONT__analogDevice"
#define MCB_SB_FRONT_SD_CSENSING_STATUS_NAME "SB_FRONT__SDCsensingStatus"
#define MCB_SB_FRONT_POTENTIOMETER_NAME "SB_FRONT__potentiometer"
#define MCB_SB_FRONT_XCP_TX_NAME "SB_FRONT__xcpTx"
#define MCB_SB_FRONT_HELLO_NAME "SB_FRONT__hello"
#define MCB_SB_FRONT_NTC_RESISTANCE_NAME "SB_FRONT__ntcResistance"
#define MCB_SB_REAR_ANALOG_DEVICE_NAME "SB_REAR__analogDevice"
#define MCB_SB_REAR_CRITICAL_PERIPHERALS_NAME "SB_REAR__criticalPeripherals"
#define MCB_SB_REAR_SD_CSENSING_STATUS_NAME "SB_REAR__SDCsensingStatus"
#define MCB_SB_REAR_POTENTIOMETER_NAME "SB_REAR__potentiometer"
#define MCB_SB_REAR_XCP_TX_NAME "SB_REAR__xcpTx"
#define MCB_SB_REAR_HELLO_NAME "SB_REAR__hello"
#define MCB_SB_REAR_NTC_RESISTANCE_NAME "SB_REAR__ntcResistance"
#define MCB_TLB_BAT_SIGNALS_STATUS_NAME "TLB_BAT__signalsStatus"
#define MCB_TLB_BAT_SD_CSENSING_STATUS_NAME "TLB_BAT__SDCsensingStatus"
#define MCB_TLB_BAT_XCP_TX_NAME "TLB_BAT__xcpTx"
#define MCB_TLB_BAT_HELLO_NAME "TLB_BAT__hello"
#define MCB_IMU_ACCELEROMETERS_NAME "IMU__Accelerometers"
#define MCB_IMU_GYRO_NAME "IMU__Gyro"
#define MCB_IMU_EULER_NAME "IMU__Euler"
#define MCB_IMU_GPS1_POSITION_NAME "IMU__GPS1_Position"
#define MCB_IMU_VELOCITY_BODY_NAME "IMU__VelocityBody"
#define MCB_IMU_TRACK_SLIP_CURV_NAME "IMU__TrackSlipCurv"
#define MCB_TPMS_FRONT_WHEELS_PRESSURE_NAME "TPMS__frontWheelsPressure"
#define MCB_TPMS_REAR_WHEELS_PRESSURE_NAME "TPMS__rearWheelsPressure"
#define MCB_NLG5_ST_NAME "NLG5_ST"
#define MCB_NLG5_ACT_I_NAME "NLG5_ACT_I"
#define MCB_NLG5_ACT_II_NAME "NLG5_ACT_II"
#define MCB_NLG5_TEMP_NAME "NLG5_TEMP"
#define MCB_NLG5_ERR_NAME "NLG5_ERR"
#define MCB_NLG5_CTL_NAME "NLG5_CTL"
#define MCB_NLG5_DIAG_RX_NAME "NLG5_DIAG_RX"
#define MCB_NLG5_DIAG_TX_NAME "NLG5_DIAG_TX"
#define MCB_BMS_LV_LV_BAT_GENERAL_NAME "BMS_LV__lvBatGeneral"
#define MCB_BMS_LV_XCP_TX_NAME "BMS_LV__xcpTx"
#define MCB_BMS_LV_CELLS_STATUS_NAME "BMS_LV__cellsStatus"
#define MCB_BMS_LV_STATUS_NAME "BMS_LV__status"
#define MCB_BMS_LV_LV_CELL_VOLTAGE0_NAME "BMS_LV__lvCellVoltage0"
#define MCB_BMS_LV_LV_CELL_VOLTAGE1_NAME "BMS_LV__lvCellVoltage1"
#define MCB_BMS_LV_HELLO_NAME "BMS_LV__hello"
#define MCB_BMS_LV_LV_CELL_NTC_RESISTANCE0_NAME "BMS_LV__lvCellNTCResistance0"
#define MCB_BMS_LV_LV_CELL_NTC_RESISTANCE1_NAME "BMS_LV__lvCellNTCResistance1"
#define MCB_DASH_HMI_DEVICES_STATE_NAME "DASH__hmiDevicesState"
#define MCB_DASH_XCP_TX_NAME "DASH__xcpTx"
#define MCB_DASH_PERIPHERALS_STATUS_NAME "DASH__peripheralsStatus"
#define MCB_DASH_HELLO_NAME "DASH__hello"
#define MCB_DASH_APPS_RANGE_LIMITS_NAME "DASH__appsRangeLimits"
#define MCB_DASH_CAR_COMMANDS_NAME "DASH__carCommands"
#define MCB_DIAG_TOOL_XCP_TX_BMS_LV_NAME "DIAG_TOOL__xcpTxBMS_LV"
#define MCB_DIAG_TOOL_XCP_TX_DASH_NAME "DIAG_TOOL__xcpTxDASH"
#define MCB_DIAG_TOOL_XCP_TX_SB_REAR_NAME "DIAG_TOOL__xcpTxSB_REAR"
#define MCB_DIAG_TOOL_XCP_TX_SB_FRONT_NAME "DIAG_TOOL__xcpTxSB_FRONT"
#define MCB_DIAG_TOOL_XCP_TX_SCANNER_NAME "DIAG_TOOL__xcpTxSCANNER"
#define MCB_DIAG_TOOL_XCP_TX_TLB_BAT_NAME "DIAG_TOOL__xcpTxTLB_BAT"
#define MCB_DSPACE_TIME_AND_DATE_NAME "DSPACE__timeAndDate"
#define MCB_DSPACE_PERIPHERALS_CTRL_NAME "DSPACE__peripheralsCTRL"
#define MCB_DSPACE_PWT_FRONT_TEMP_NAME "DSPACE__pwtFrontTemp"
#define MCB_DSPACE_PWT_REAR_TEMP_NAME "DSPACE__pwtRearTemp"
#define MCB_DSPACE_XCP_TX_NAME "DSPACE__xcpTx"
#define MCB_DSPACE_SIGNALS_NAME "DSPACE__signals"
#define MCB_DSPACE_FSM_STATES_NAME "DSPACE__fsmStates"
#define MCB_DSPACE_HELLO_NAME "DSPACE__hello"
#define MCB_DSPACE_DASH_LEDS_COLOR_RGB_NAME "DSPACE__dashLedsColorRGB"
#define MCB_SCANNER_XCP_TX_NAME "SCANNER__xcpTx"

/* Signal Names. */
#define MCB_IRTS_PLACEHOLDER_MESSAGE_IRTS_SIGNAL_PLACEHOLDER_NAME "IRTS_signalPlaceholder"
#define MCB_SB_FRONT_ANALOG_DEVICE_APPS_0_VOLTAGE_NAME "APPS_0_voltage"
#define MCB_SB_FRONT_ANALOG_DEVICE_APPS_1_VOLTAGE_NAME "APPS_1_voltage"
#define MCB_SB_FRONT_ANALOG_DEVICE_STEER_RME_VOLTAGE_NAME "STEER_RME_voltage"
#define MCB_SB_FRONT_ANALOG_DEVICE_BRAKE_PRESS_FRONT_VOLTAGE_NAME "BRAKE_PRESS_FRONT_voltage"
#define MCB_SB_FRONT_SD_CSENSING_STATUS_SDC_POST_INERTIA_IS_ACTIVE_NAME "SDC_POST_INERTIA_isActive"
#define MCB_SB_FRONT_SD_CSENSING_STATUS_SDC_POST_BOTS_IS_ACTIVE_NAME "SDC_POST_BOTS_isActive"
#define MCB_SB_FRONT_SD_CSENSING_STATUS_SDC_POST_CP_PUSH_BTN_IS_ACTIVE_NAME "SDC_POST_CP_PUSH_BTN_isActive"
#define MCB_SB_FRONT_POTENTIOMETER_LPPS_DAMPER_FL_VOLTAGE_NAME "LPPS_DAMPER_FL_voltage"
#define MCB_SB_FRONT_POTENTIOMETER_LPPS_DAMPER_FR_VOLTAGE_NAME "LPPS_DAMPER_FR_voltage"
#define MCB_SB_FRONT_XCP_TX_XCP_PAYLOAD_NAME "xcp_payload"
#define MCB_SB_FRONT_HELLO_FW_MAJOR_VERSION_NAME "FW_majorVersion"
#define MCB_SB_FRONT_HELLO_FW_MINOR_VERSION_NAME "FW_minorVersion"
#define MCB_SB_FRONT_HELLO_FW_PATCH_VERSION_NAME "FW_patchVersion"
#define MCB_SB_FRONT_NTC_RESISTANCE_JACKET_FL_NTC_RESISTANCE_NAME "JACKET_FL_NTC_resistance"
#define MCB_SB_FRONT_NTC_RESISTANCE_JACKET_FR_NTC_RESISTANCE_NAME "JACKET_FR_NTC_resistance"
#define MCB_SB_FRONT_NTC_RESISTANCE_COLDPLATE_L_NTC_RESISTANCE_NAME "COLDPLATE_L_NTC_resistance"
#define MCB_SB_FRONT_NTC_RESISTANCE_COLDPLATE_R_NTC_RESISTANCE_NAME "COLDPLATE_R_NTC_resistance"
#define MCB_SB_FRONT_NTC_RESISTANCE_SPARE_NTC_0_RESISTANCE_NAME "SPARE_NTC_0_resistance"
#define MCB_SB_FRONT_NTC_RESISTANCE_SPARE_NTC_1_RESISTANCE_NAME "SPARE_NTC_1_resistance"
#define MCB_SB_REAR_ANALOG_DEVICE_COOL_PRESS_LEFT_VOLTAGE_NAME "COOL_PRESS_LEFT_voltage"
#define MCB_SB_REAR_ANALOG_DEVICE_COOL_PRESS_RIGHT_VOLTAGE_NAME "COOL_PRESS_RIGHT_voltage"
#define MCB_SB_REAR_ANALOG_DEVICE_BRAKE_PRESS_REAR_VOLTAGE_NAME "BRAKE_PRESS_REAR_voltage"
#define MCB_SB_REAR_CRITICAL_PERIPHERALS_DISCHARGE_IS_ACTIVE_NAME "DISCHARGE_isActive"
#define MCB_SB_REAR_CRITICAL_PERIPHERALS_BSPD_HAS_ERROR_NAME "BSPD_hasError"
#define MCB_SB_REAR_SD_CSENSING_STATUS_SDC_POST_BSPD_IS_CLOSED_NAME "SDC_POST_BSPD_isClosed"
#define MCB_SB_REAR_SD_CSENSING_STATUS_SDC_PRE_PUSH_BTNS_IS_CLOSED_NAME "SDC_PRE_PUSH_BTNS_isClosed"
#define MCB_SB_REAR_SD_CSENSING_STATUS_SDC_POST_DC_BUS_IS_CLOSED_NAME "SDC_POST_DC_BUS_isClosed"
#define MCB_SB_REAR_SD_CSENSING_STATUS_SDC_POST_INV_FR_IS_CLOSED_NAME "SDC_POST_INV_FR_isClosed"
#define MCB_SB_REAR_POTENTIOMETER_LPPS_DAMPER_RL_VOLTAGE_NAME "LPPS_DAMPER_RL_voltage"
#define MCB_SB_REAR_POTENTIOMETER_LPPS_DAMPER_RR_VOLTAGE_NAME "LPPS_DAMPER_RR_voltage"
#define MCB_SB_REAR_XCP_TX_XCP_PAYLOAD_NAME "xcp_payload"
#define MCB_SB_REAR_HELLO_FW_MAJOR_VERSION_NAME "FW_majorVersion"
#define MCB_SB_REAR_HELLO_FW_MINOR_VERSION_NAME "FW_minorVersion"
#define MCB_SB_REAR_HELLO_FW_PATCH_VERSION_NAME "FW_patchVersion"
#define MCB_SB_REAR_NTC_RESISTANCE_JACKET_RL_NTC_RESISTANCE_NAME "JACKET_RL_NTC_resistance"
#define MCB_SB_REAR_NTC_RESISTANCE_JACKET_RR_NTC_RESISTANCE_NAME "JACKET_RR_NTC_resistance"
#define MCB_SB_REAR_NTC_RESISTANCE_RAD_RL_IN_NTC_RESISTANCE_NAME "RAD_RL_IN_NTC_resistance"
#define MCB_SB_REAR_NTC_RESISTANCE_RAD_RL_OUT_NTC_RESISTANCE_NAME "RAD_RL_OUT_NTC_resistance"
#define MCB_SB_REAR_NTC_RESISTANCE_RAD_RR_IN_NTC_RESISTANCE_NAME "RAD_RR_IN_NTC_resistance"
#define MCB_SB_REAR_NTC_RESISTANCE_RAD_RR_OUT_NTC_RESISTANCE_NAME "RAD_RR_OUT_NTC_resistance"
#define MCB_TLB_BAT_SIGNALS_STATUS_AIR_POS_CMD_IS_ACTIVE_NAME "AIR_POS_cmd_isActive"
#define MCB_TLB_BAT_SIGNALS_STATUS_AIR_POS_IS_CLOSED_NAME "AIR_POS_isClosed"
#define MCB_TLB_BAT_SIGNALS_STATUS_AIR_NEG_CMD_IS_ACTIVE_NAME "AIR_NEG_cmd_isActive"
#define MCB_TLB_BAT_SIGNALS_STATUS_AIR_NEG_IS_CLOSED_NAME "AIR_NEG_isClosed"
#define MCB_TLB_BAT_SIGNALS_STATUS_DCBUS_PRECH_RLY_CMD_IS_ACTIVE_NAME "DCBUS_PRECH_RLY_cmd_isActive"
#define MCB_TLB_BAT_SIGNALS_STATUS_DCBUS_PRECH_RLY_IS_CLOSED_NAME "DCBUS_PRECH_RLY_isClosed"
#define MCB_TLB_BAT_SIGNALS_STATUS_AMS_ERR_IS_ACTIVE_NAME "AMS_err_isActive"
#define MCB_TLB_BAT_SIGNALS_STATUS_IMD_ERR_IS_ACTIVE_NAME "IMD_err_isActive"
#define MCB_TLB_BAT_SIGNALS_STATUS_TSAL_GREEN_IS_ACTIVE_NAME "TSAL_green_isActive"
#define MCB_TLB_BAT_SIGNALS_STATUS_DCBUS_IS_OVER60_V_NAME "DCBUS_isOver60V"
#define MCB_TLB_BAT_SIGNALS_STATUS_IMP_ANY_IS_ACTIVE_NAME "IMP_any_isActive"
#define MCB_TLB_BAT_SIGNALS_STATUS_IMP_HV_RELAYS_STATE_IS_ACTIVE_NAME "IMP_HV_RelaysState_isActive"
#define MCB_TLB_BAT_SIGNALS_STATUS_IMP_DCBUS_IS_ACTIVE_NAME "IMP_DCBUS_isActive"
#define MCB_TLB_BAT_SIGNALS_STATUS_AIR_POS_STG_MECH_STATE_SIGNAL_IS_ACTIVE_NAME "AIR_POS_STG_mechStateSignal_isActive"
#define MCB_TLB_BAT_SIGNALS_STATUS_AIR_NEG_STG_MECH_STATE_SIGNAL_IS_ACTIVE_NAME "AIR_NEG_STG_mechStateSignal_isActive"
#define MCB_TLB_BAT_SD_CSENSING_STATUS_SDC_TSAC_INITIAL_IN_IS_ACTIVE_NAME "SDC_TSAC_initialIn_isActive"
#define MCB_TLB_BAT_SD_CSENSING_STATUS_SDC_POST_AMS_IMD_RELAY_IS_ACTIVE_NAME "SDC_post_AMS_IMD_relay_isActive"
#define MCB_TLB_BAT_SD_CSENSING_STATUS_SDC_TSAC_FINAL_IN_IS_ACTIVE_NAME "SDC_TSAC_finalIn_isActive"
#define MCB_TLB_BAT_SD_CSENSING_STATUS_SDC_PRECH_BYPASS_RELAY_IS_CLOSED_NAME "SDC_PrechBypassRelay_isClosed"
#define MCB_TLB_BAT_SD_CSENSING_STATUS_SDC_TSAC_INITIAL_IN_VOLTAGE_NAME "SDC_TSAC_initialIn_voltage"
#define MCB_TLB_BAT_SD_CSENSING_STATUS_SDC_TSAC_FINAL_IN_VOLTAGE_NAME "SDC_TSAC_finalIn_voltage"
#define MCB_TLB_BAT_XCP_TX_XCP_PAYLOAD_NAME "xcp_payload"
#define MCB_TLB_BAT_HELLO_FW_MAJOR_VERSION_NAME "FW_majorVersion"
#define MCB_TLB_BAT_HELLO_FW_MINOR_VERSION_NAME "FW_minorVersion"
#define MCB_TLB_BAT_HELLO_FW_PATCH_VERSION_NAME "FW_patchVersion"
#define MCB_IMU_ACCELEROMETERS_ACCEL_X_NAME "ACCEL_X"
#define MCB_IMU_ACCELEROMETERS_ACCEL_Y_NAME "ACCEL_Y"
#define MCB_IMU_ACCELEROMETERS_ACCEL_Z_NAME "ACCEL_Z"
#define MCB_IMU_GYRO_GYRO_X_NAME "GYRO_X"
#define MCB_IMU_GYRO_GYRO_Y_NAME "GYRO_Y"
#define MCB_IMU_GYRO_GYRO_Z_NAME "GYRO_Z"
#define MCB_IMU_EULER_ROLL_NAME "ROLL"
#define MCB_IMU_EULER_PITCH_NAME "PITCH"
#define MCB_IMU_EULER_YAW_NAME "YAW"
#define MCB_IMU_GPS1_POSITION_LATITUDE_NAME "LATITUDE"
#define MCB_IMU_GPS1_POSITION_LONGITUDE_NAME "LONGITUDE"
#define MCB_IMU_VELOCITY_BODY_VELOCITY_X_NAME "VELOCITY_X"
#define MCB_IMU_VELOCITY_BODY_VELOCITY_Y_NAME "VELOCITY_Y"
#define MCB_IMU_VELOCITY_BODY_VELOCITY_Z_NAME "VELOCITY_Z"
#define MCB_IMU_TRACK_SLIP_CURV_ANGLE_TRACK_NAME "ANGLE_TRACK"
#define MCB_IMU_TRACK_SLIP_CURV_ANGLE_SLIP_NAME "ANGLE_SLIP"
#define MCB_IMU_TRACK_SLIP_CURV_CURVATURE_RADIUS_NAME "CURVATURE_RADIUS"
#define MCB_IMU_TRACK_SLIP_CURV_AUTO_STATUS_NAME "AUTO_STATUS"
#define MCB_TPMS_FRONT_WHEELS_PRESSURE_TIRE_FL_SENS_ID_NAME "TIRE_FL_sensID"
#define MCB_TPMS_FRONT_WHEELS_PRESSURE_TIRE_FL_STATUS_IS_SPINNING_NAME "TIRE_FL_statusIsSpinning"
#define MCB_TPMS_FRONT_WHEELS_PRESSURE_TIRE_FL_STATUS_IS_VBATT_NOT_OK_NAME "TIRE_FL_statusIsVbattNotOk"
#define MCB_TPMS_FRONT_WHEELS_PRESSURE_TIRE_FL_TEMPERATURE_NAME "TIRE_FL_temperature"
#define MCB_TPMS_FRONT_WHEELS_PRESSURE_TIRE_FL_PRESSURE_NAME "TIRE_FL_pressure"
#define MCB_TPMS_FRONT_WHEELS_PRESSURE_TIRE_FR_SENS_ID_NAME "TIRE_FR_sensID"
#define MCB_TPMS_FRONT_WHEELS_PRESSURE_TIRE_FR_STATUS_IS_SPINNING_NAME "TIRE_FR_statusIsSpinning"
#define MCB_TPMS_FRONT_WHEELS_PRESSURE_TIRE_FR_STATUS_IS_VBATT_NOT_OK_NAME "TIRE_FR_statusIsVbattNotOk"
#define MCB_TPMS_FRONT_WHEELS_PRESSURE_TIRE_FR_TEMPERATURE_NAME "TIRE_FR_temperature"
#define MCB_TPMS_FRONT_WHEELS_PRESSURE_TIRE_FR_PRESSURE_NAME "TIRE_FR_pressure"
#define MCB_TPMS_REAR_WHEELS_PRESSURE_TIRE_RL_SENS_ID_NAME "TIRE_RL_sensID"
#define MCB_TPMS_REAR_WHEELS_PRESSURE_TIRE_RL_STATUS_IS_SPINNING_NAME "TIRE_RL_statusIsSpinning"
#define MCB_TPMS_REAR_WHEELS_PRESSURE_TIRE_RL_STATUS_IS_VBATT_NOT_OK_NAME "TIRE_RL_statusIsVbattNotOk"
#define MCB_TPMS_REAR_WHEELS_PRESSURE_TIRE_RL_TEMPERATURE_NAME "TIRE_RL_temperature"
#define MCB_TPMS_REAR_WHEELS_PRESSURE_TIRE_RL_PRESSURE_NAME "TIRE_RL_pressure"
#define MCB_TPMS_REAR_WHEELS_PRESSURE_TIRE_RR_SENS_ID_NAME "TIRE_RR_sensID"
#define MCB_TPMS_REAR_WHEELS_PRESSURE_TIRE_RR_STATUS_IS_SPINNING_NAME "TIRE_RR_statusIsSpinning"
#define MCB_TPMS_REAR_WHEELS_PRESSURE_TIRE_RR_STATUS_IS_VBATT_NOT_OK_NAME "TIRE_RR_statusIsVbattNotOk"
#define MCB_TPMS_REAR_WHEELS_PRESSURE_TIRE_RR_TEMPERATURE_NAME "TIRE_RR_temperature"
#define MCB_TPMS_REAR_WHEELS_PRESSURE_TIRE_RR_PRESSURE_NAME "TIRE_RR_pressure"
#define MCB_NLG5_ST_NLG5_S_HE_NAME "NLG5_S_HE"
#define MCB_NLG5_ST_NLG5_S_ERR_NAME "NLG5_S_ERR"
#define MCB_NLG5_ST_NLG5_S_WAR_NAME "NLG5_S_WAR"
#define MCB_NLG5_ST_NLG5_S_FAN_NAME "NLG5_S_FAN"
#define MCB_NLG5_ST_NLG5_S_EUM_NAME "NLG5_S_EUM"
#define MCB_NLG5_ST_NLG5_S_UM_I_NAME "NLG5_S_UM_I"
#define MCB_NLG5_ST_NLG5_S_UM_II_NAME "NLG5_S_UM_II"
#define MCB_NLG5_ST_NLG5_S_CP_DT_NAME "NLG5_S_CP_DT"
#define MCB_NLG5_ST_NLG5_S_BPD_I_NAME "NLG5_S_BPD_I"
#define MCB_NLG5_ST_NLG5_S_BPD_II_NAME "NLG5_S_BPD_II"
#define MCB_NLG5_ST_NLG5_S_L_OV_NAME "NLG5_S_L_OV"
#define MCB_NLG5_ST_NLG5_S_L_OC_NAME "NLG5_S_L_OC"
#define MCB_NLG5_ST_NLG5_S_L_MC_NAME "NLG5_S_L_MC"
#define MCB_NLG5_ST_NLG5_S_L_PI_NAME "NLG5_S_L_PI"
#define MCB_NLG5_ST_NLG5_S_L_CP_NAME "NLG5_S_L_CP"
#define MCB_NLG5_ST_NLG5_S_L_PMAX_NAME "NLG5_S_L_PMAX"
#define MCB_NLG5_ST_NLG5_S_L_MC_MAX_NAME "NLG5_S_L_MC_MAX"
#define MCB_NLG5_ST_NLG5_S_L_OC_MAX_NAME "NLG5_S_L_OC_MAX"
#define MCB_NLG5_ST_NLG5_S_L_MO_MAX_NAME "NLG5_S_L_MO_MAX"
#define MCB_NLG5_ST_NLG5_S_L_T_CPRIM_NAME "NLG5_S_L_T_CPRIM"
#define MCB_NLG5_ST_NLG5_S_L_T_POW_NAME "NLG5_S_L_T_POW"
#define MCB_NLG5_ST_NLG5_S_L_T_DIO_NAME "NLG5_S_L_T_DIO"
#define MCB_NLG5_ST_NLG5_S_L_T_TR_NAME "NLG5_S_L_T_TR"
#define MCB_NLG5_ST_NLG5_S_L_T_BATT_NAME "NLG5_S_L_T_BATT"
#define MCB_NLG5_ST_NLG5_S_AAC_NAME "NLG5_S_AAC"
#define MCB_NLG5_ACT_I_NLG5_MC_ACT_NAME "NLG5_MC_ACT"
#define MCB_NLG5_ACT_I_NLG5_MV_ACT_NAME "NLG5_MV_ACT"
#define MCB_NLG5_ACT_I_NLG5_OV_ACT_NAME "NLG5_OV_ACT"
#define MCB_NLG5_ACT_I_NLG5_OC_ACT_NAME "NLG5_OC_ACT"
#define MCB_NLG5_ACT_II_NLG5_S_MC_M_CP_NAME "NLG5_S_MC_M_CP"
#define MCB_NLG5_ACT_II_NLG5_S_MC_M_PI_NAME "NLG5_S_MC_M_PI"
#define MCB_NLG5_ACT_II_NLG5_ABV_NAME "NLG5_ABV"
#define MCB_NLG5_ACT_II_NLG5_AHC_EXT_NAME "NLG5_AHC_EXT"
#define MCB_NLG5_ACT_II_NLG5_OC_BO_NAME "NLG5_OC_BO"
#define MCB_NLG5_TEMP_NLG5_P_TMP_NAME "NLG5_P_TMP"
#define MCB_NLG5_TEMP_NLG5_TMP_EXT1_NAME "NLG5_TMP_EXT1"
#define MCB_NLG5_TEMP_NLG5_TEMP_EXT2_NAME "NLG5_TEMP_EXT2"
#define MCB_NLG5_TEMP_NLG5_TMP_EXT3_NAME "NLG5_TMP_EXT3"
#define MCB_NLG5_ERR_NLG5_E_OOV_NAME "NLG5_E_OOV"
#define MCB_NLG5_ERR_NLG5_E_MOV_II_NAME "NLG5_E_MOV_II"
#define MCB_NLG5_ERR_NLG5_E_MOV_I_NAME "NLG5_E_MOV_I"
#define MCB_NLG5_ERR_NLG5_E_SC_NAME "NLG5_E_SC"
#define MCB_NLG5_ERR_NLG5_E_P_OM_NAME "NLG5_E_P_OM"
#define MCB_NLG5_ERR_NLG5_E_P_MV_NAME "NLG5_E_P_MV"
#define MCB_NLG5_ERR_NLG5_E_OF_NAME "NLG5_E_OF"
#define MCB_NLG5_ERR_NLG5_E_MF_NAME "NLG5_E_MF"
#define MCB_NLG5_ERR_NLG5_E_B_P_NAME "NLG5_E_B_P"
#define MCB_NLG5_ERR_NLG5_E_T_C_NAME "NLG5_E_T_C"
#define MCB_NLG5_ERR_NLG5_E_T_POW_NAME "NLG5_E_T_POW"
#define MCB_NLG5_ERR_NLG5_E_T_DIO_NAME "NLG5_E_T_DIO"
#define MCB_NLG5_ERR_NLG5_E_T_TR_NAME "NLG5_E_T_TR"
#define MCB_NLG5_ERR_NLG5_E_T_EXT1_NAME "NLG5_E_T_EXT1"
#define MCB_NLG5_ERR_NLG5_E_T_EXT2_NAME "NLG5_E_T_EXT2"
#define MCB_NLG5_ERR_NLG5_E_T_EXT3_NAME "NLG5_E_T_EXT3"
#define MCB_NLG5_ERR_NLG5_E_F_CRC_NAME "NLG5_E_F_CRC"
#define MCB_NLG5_ERR_NLG5_E_NV_CRC_NAME "NLG5_E_NV_CRC"
#define MCB_NLG5_ERR_NLG5_E_ES_CRC_NAME "NLG5_E_ES_CRC"
#define MCB_NLG5_ERR_NLG5_E_EP_CRC_NAME "NLG5_E_EP_CRC"
#define MCB_NLG5_ERR_NLG5_E_WDT_NAME "NLG5_E_WDT"
#define MCB_NLG5_ERR_NLG5_E_INIT_NAME "NLG5_E_INIT"
#define MCB_NLG5_ERR_NLG5_E_C_TO_NAME "NLG5_E_C_TO"
#define MCB_NLG5_ERR_NLG5_E_C_OFF_NAME "NLG5_E_C_OFF"
#define MCB_NLG5_ERR_NLG5_E_C_TX_NAME "NLG5_E_C_TX"
#define MCB_NLG5_ERR_NLG5_E_C_RX_NAME "NLG5_E_C_RX"
#define MCB_NLG5_ERR_NLG5_E_SDT_BT_NAME "NLG5_E_SDT_BT"
#define MCB_NLG5_ERR_NLG5_E_SDT_BV_NAME "NLG5_E_SDT_BV"
#define MCB_NLG5_ERR_NLG5_E_SDT_AH_NAME "NLG5_E_SDT_AH"
#define MCB_NLG5_ERR_NLG5_E_SDT_CT_NAME "NLG5_E_SDT_CT"
#define MCB_NLG5_ERR_NLG5_W_PL_MV_NAME "NLG5_W_PL_MV"
#define MCB_NLG5_ERR_NLG5_W_PL_BV_NAME "NLG5_W_PL_BV"
#define MCB_NLG5_ERR_NLG5_W_PL_IT_NAME "NLG5_W_PL_IT"
#define MCB_NLG5_ERR_NLG5_W_C_VOR_NAME "NLG5_W_C_VOR"
#define MCB_NLG5_ERR_NLG5_W_CM_NA_NAME "NLG5_W_CM_NA"
#define MCB_NLG5_ERR_NLG5_W_OD_NAME "NLG5_W_OD"
#define MCB_NLG5_ERR_NLG5_W_SC_M_NAME "NLG5_W_SC_M"
#define MCB_NLG5_CTL_NLG5_C_C_EN_NAME "NLG5_C_C_EN"
#define MCB_NLG5_CTL_NLG5_C_C_EL_NAME "NLG5_C_C_EL"
#define MCB_NLG5_CTL_NLG5_C_CP_V_NAME "NLG5_C_CP_V"
#define MCB_NLG5_CTL_NLG5_C_MR_NAME "NLG5_C_MR"
#define MCB_NLG5_CTL_NLG5_MC_MAX_NAME "NLG5_MC_MAX"
#define MCB_NLG5_CTL_NLG5_OV_COM_NAME "NLG5_OV_COM"
#define MCB_NLG5_CTL_NLG5_OC_COM_NAME "NLG5_OC_COM"
#define MCB_NLG5_DIAG_RX_LAD_D_PARAM_RQ_NAME "LAD_D_ParamRq"
#define MCB_NLG5_DIAG_TX_LAD_D_PARAM_RP_NAME "LAD_D_ParamRp"
#define MCB_BMS_LV_LV_BAT_GENERAL_LV_BAT_CURRENT_SENS_VOLTAGE_NAME "LV_BAT_currentSensVoltage"
#define MCB_BMS_LV_LV_BAT_GENERAL_LV_BAT_VOLTAGE_NAME "LV_BAT_voltage"
#define MCB_BMS_LV_LV_BAT_GENERAL_LV_BAT_SUMMED_VOLTAGE_NAME "LV_BAT_summedVoltage"
#define MCB_BMS_LV_XCP_TX_XCP_PAYLOAD_NAME "xcp_payload"
#define MCB_BMS_LV_CELLS_STATUS_LV_CELL_0_IS_OV_NAME "LV_CELL_0_isOV"
#define MCB_BMS_LV_CELLS_STATUS_LV_CELL_0_IS_UV_NAME "LV_CELL_0_isUV"
#define MCB_BMS_LV_CELLS_STATUS_LV_CELL_1_IS_OV_NAME "LV_CELL_1_isOV"
#define MCB_BMS_LV_CELLS_STATUS_LV_CELL_1_IS_UV_NAME "LV_CELL_1_isUV"
#define MCB_BMS_LV_CELLS_STATUS_LV_CELL_2_IS_OV_NAME "LV_CELL_2_isOV"
#define MCB_BMS_LV_CELLS_STATUS_LV_CELL_2_IS_UV_NAME "LV_CELL_2_isUV"
#define MCB_BMS_LV_CELLS_STATUS_LV_CELL_3_IS_OV_NAME "LV_CELL_3_isOV"
#define MCB_BMS_LV_CELLS_STATUS_LV_CELL_3_IS_UV_NAME "LV_CELL_3_isUV"
#define MCB_BMS_LV_CELLS_STATUS_LV_CELL_4_IS_OV_NAME "LV_CELL_4_isOV"
#define MCB_BMS_LV_CELLS_STATUS_LV_CELL_4_IS_UV_NAME "LV_CELL_4_isUV"
#define MCB_BMS_LV_CELLS_STATUS_LV_CELL_5_IS_OV_NAME "LV_CELL_5_isOV"
#define MCB_BMS_LV_CELLS_STATUS_LV_CELL_5_IS_UV_NAME "LV_CELL_5_isUV"
#define MCB_BMS_LV_CELLS_STATUS_LV_CELL_6_IS_OV_NAME "LV_CELL_6_isOV"
#define MCB_BMS_LV_CELLS_STATUS_LV_CELL_6_IS_UV_NAME "LV_CELL_6_isUV"
#define MCB_BMS_LV_CELLS_STATUS_LV_CELL_NTC_00_IS_OT_NAME "LV_CELL_NTC_00_isOT"
#define MCB_BMS_LV_CELLS_STATUS_LV_CELL_NTC_01_IS_OT_NAME "LV_CELL_NTC_01_isOT"
#define MCB_BMS_LV_CELLS_STATUS_LV_CELL_NTC_02_IS_OT_NAME "LV_CELL_NTC_02_isOT"
#define MCB_BMS_LV_CELLS_STATUS_LV_CELL_NTC_03_IS_OT_NAME "LV_CELL_NTC_03_isOT"
#define MCB_BMS_LV_CELLS_STATUS_LV_CELL_NTC_04_IS_OT_NAME "LV_CELL_NTC_04_isOT"
#define MCB_BMS_LV_CELLS_STATUS_LV_CELL_NTC_05_IS_OT_NAME "LV_CELL_NTC_05_isOT"
#define MCB_BMS_LV_CELLS_STATUS_LV_CELL_NTC_06_IS_OT_NAME "LV_CELL_NTC_06_isOT"
#define MCB_BMS_LV_CELLS_STATUS_LV_CELL_NTC_07_IS_OT_NAME "LV_CELL_NTC_07_isOT"
#define MCB_BMS_LV_CELLS_STATUS_LV_CELL_NTC_08_IS_OT_NAME "LV_CELL_NTC_08_isOT"
#define MCB_BMS_LV_CELLS_STATUS_LV_CELL_NTC_09_IS_OT_NAME "LV_CELL_NTC_09_isOT"
#define MCB_BMS_LV_CELLS_STATUS_LV_CELL_NTC_10_IS_OT_NAME "LV_CELL_NTC_10_isOT"
#define MCB_BMS_LV_CELLS_STATUS_LV_CELL_NTC_11_IS_OT_NAME "LV_CELL_NTC_11_isOT"
#define MCB_BMS_LV_STATUS_LV_RELAY_IS_CLOSED_NAME "LV_RELAY_isClosed"
#define MCB_BMS_LV_STATUS_LV_RELAY_IS_RELAY_OVERRIDE_ON_NAME "LV_RELAY_isRelayOverrideOn"
#define MCB_BMS_LV_LV_CELL_VOLTAGE0_LV_CELL_0_VOLTAGE_NAME "LV_CELL_0_voltage"
#define MCB_BMS_LV_LV_CELL_VOLTAGE0_LV_CELL_1_VOLTAGE_NAME "LV_CELL_1_voltage"
#define MCB_BMS_LV_LV_CELL_VOLTAGE0_LV_CELL_2_VOLTAGE_NAME "LV_CELL_2_voltage"
#define MCB_BMS_LV_LV_CELL_VOLTAGE0_LV_CELL_3_VOLTAGE_NAME "LV_CELL_3_voltage"
#define MCB_BMS_LV_LV_CELL_VOLTAGE1_LV_CELL_4_VOLTAGE_NAME "LV_CELL_4_voltage"
#define MCB_BMS_LV_LV_CELL_VOLTAGE1_LV_CELL_5_VOLTAGE_NAME "LV_CELL_5_voltage"
#define MCB_BMS_LV_LV_CELL_VOLTAGE1_LV_CELL_6_VOLTAGE_NAME "LV_CELL_6_voltage"
#define MCB_BMS_LV_HELLO_FW_MAJOR_VERSION_NAME "FW_majorVersion"
#define MCB_BMS_LV_HELLO_FW_MINOR_VERSION_NAME "FW_minorVersion"
#define MCB_BMS_LV_HELLO_FW_PATCH_VERSION_NAME "FW_patchVersion"
#define MCB_BMS_LV_LV_CELL_NTC_RESISTANCE0_LV_CELL_NTC_00_RESISTANCE_NAME "LV_CELL_NTC_00_resistance"
#define MCB_BMS_LV_LV_CELL_NTC_RESISTANCE0_LV_CELL_NTC_01_RESISTANCE_NAME "LV_CELL_NTC_01_resistance"
#define MCB_BMS_LV_LV_CELL_NTC_RESISTANCE0_LV_CELL_NTC_02_RESISTANCE_NAME "LV_CELL_NTC_02_resistance"
#define MCB_BMS_LV_LV_CELL_NTC_RESISTANCE0_LV_CELL_NTC_03_RESISTANCE_NAME "LV_CELL_NTC_03_resistance"
#define MCB_BMS_LV_LV_CELL_NTC_RESISTANCE0_LV_CELL_NTC_04_RESISTANCE_NAME "LV_CELL_NTC_04_resistance"
#define MCB_BMS_LV_LV_CELL_NTC_RESISTANCE0_LV_CELL_NTC_05_RESISTANCE_NAME "LV_CELL_NTC_05_resistance"
#define MCB_BMS_LV_LV_CELL_NTC_RESISTANCE1_LV_CELL_NTC_06_RESISTANCE_NAME "LV_CELL_NTC_06_resistance"
#define MCB_BMS_LV_LV_CELL_NTC_RESISTANCE1_LV_CELL_NTC_07_RESISTANCE_NAME "LV_CELL_NTC_07_resistance"
#define MCB_BMS_LV_LV_CELL_NTC_RESISTANCE1_LV_CELL_NTC_08_RESISTANCE_NAME "LV_CELL_NTC_08_resistance"
#define MCB_BMS_LV_LV_CELL_NTC_RESISTANCE1_LV_CELL_NTC_09_RESISTANCE_NAME "LV_CELL_NTC_09_resistance"
#define MCB_BMS_LV_LV_CELL_NTC_RESISTANCE1_LV_CELL_NTC_10_RESISTANCE_NAME "LV_CELL_NTC_10_resistance"
#define MCB_BMS_LV_LV_CELL_NTC_RESISTANCE1_LV_CELL_NTC_11_RESISTANCE_NAME "LV_CELL_NTC_11_resistance"
#define MCB_DASH_HMI_DEVICES_STATE_BTN_1_IS_PRESSED_NAME "BTN_1_isPressed"
#define MCB_DASH_HMI_DEVICES_STATE_BTN_2_IS_PRESSED_NAME "BTN_2_isPressed"
#define MCB_DASH_HMI_DEVICES_STATE_BTN_3_IS_PRESSED_NAME "BTN_3_isPressed"
#define MCB_DASH_HMI_DEVICES_STATE_BTN_4_IS_PRESSED_NAME "BTN_4_isPressed"
#define MCB_DASH_HMI_DEVICES_STATE_BTN_5_IS_PRESSED_NAME "BTN_5_isPressed"
#define MCB_DASH_HMI_DEVICES_STATE_ROT_SW_1_STATE_NAME "ROT_SW_1_state"
#define MCB_DASH_HMI_DEVICES_STATE_ROT_SW_2_STATE_NAME "ROT_SW_2_state"
#define MCB_DASH_HMI_DEVICES_STATE_ROT_SW_3_STATE_NAME "ROT_SW_3_state"
#define MCB_DASH_XCP_TX_XCP_PAYLOAD_NAME "xcp_payload"
#define MCB_DASH_PERIPHERALS_STATUS_TSAC_FAN_PWM_DUTY_CYCLE_STATUS_NAME "TSAC_FAN_pwmDutyCycleStatus"
#define MCB_DASH_HELLO_FW_MAJOR_VERSION_NAME "FW_majorVersion"
#define MCB_DASH_HELLO_FW_MINOR_VERSION_NAME "FW_minorVersion"
#define MCB_DASH_HELLO_FW_PATCH_VERSION_NAME "FW_patchVersion"
#define MCB_DASH_APPS_RANGE_LIMITS_APPS_0_VOLTAGE_RANGE_MIN_NAME "APPS_0_voltageRangeMin"
#define MCB_DASH_APPS_RANGE_LIMITS_APPS_0_VOLTAGE_RANGE_MAX_NAME "APPS_0_voltageRangeMax"
#define MCB_DASH_APPS_RANGE_LIMITS_APPS_1_VOLTAGE_RANGE_MIN_NAME "APPS_1_voltageRangeMin"
#define MCB_DASH_APPS_RANGE_LIMITS_APPS_1_VOLTAGE_RANGE_MAX_NAME "APPS_1_voltageRangeMax"
#define MCB_DASH_CAR_COMMANDS_BMS_LV_DIAG_PWD_NAME "BMS_LV_diagPWD"
#define MCB_DASH_CAR_COMMANDS_LV_RELAY_OVERRIDE_STATE_NAME "LV_RELAY_overrideState"
#define MCB_DIAG_TOOL_XCP_TX_BMS_LV_XCP_PAYLOAD_NAME "xcp_payload"
#define MCB_DIAG_TOOL_XCP_TX_DASH_XCP_PAYLOAD_NAME "xcp_payload"
#define MCB_DIAG_TOOL_XCP_TX_SB_REAR_XCP_PAYLOAD_NAME "xcp_payload"
#define MCB_DIAG_TOOL_XCP_TX_SB_FRONT_XCP_PAYLOAD_NAME "xcp_payload"
#define MCB_DIAG_TOOL_XCP_TX_SCANNER_XCP_PAYLOAD_NAME "xcp_payload"
#define MCB_DIAG_TOOL_XCP_TX_TLB_BAT_XCP_PAYLOAD_NAME "xcp_payload"
#define MCB_DSPACE_TIME_AND_DATE_DATETIME_YEAR_NAME "DATETIME_year"
#define MCB_DSPACE_TIME_AND_DATE_DATETIME_MONTH_NAME "DATETIME_month"
#define MCB_DSPACE_TIME_AND_DATE_DATETIME_DAY_NAME "DATETIME_day"
#define MCB_DSPACE_TIME_AND_DATE_DATETIME_HOURS_NAME "DATETIME_hours"
#define MCB_DSPACE_TIME_AND_DATE_DATETIME_MINUTES_NAME "DATETIME_minutes"
#define MCB_DSPACE_TIME_AND_DATE_DATETIME_SECONDS_NAME "DATETIME_seconds"
#define MCB_DSPACE_TIME_AND_DATE_DATETIME_HOUNDRES_OF_A_SECONDS_NAME "DATETIME_houndresOfASeconds"
#define MCB_DSPACE_PERIPHERALS_CTRL_BRAKE_LIGHT_ACTIVE_CMD_NAME "BRAKE_LIGHT_activeCMD"
#define MCB_DSPACE_PERIPHERALS_CTRL_DASH_SDC_RLY_CLOSE_CMD_NAME "DASH_SDC_RLY_closeCMD"
#define MCB_DSPACE_PERIPHERALS_CTRL_RAD_FAN_PWM_DUTY_CICLE_CTRL_NAME "RAD_FAN_pwmDutyCicleCtrl"
#define MCB_DSPACE_PERIPHERALS_CTRL_COOL_PUMPS_SPEED_CTRL_NAME "COOL_PUMPS_speedCtrl"
#define MCB_DSPACE_PWT_FRONT_TEMP_INVERTER_FL_TEMP_NAME "INVERTER_FL_temp"
#define MCB_DSPACE_PWT_FRONT_TEMP_MOTOR_FL_TEMP_NAME "MOTOR_FL_temp"
#define MCB_DSPACE_PWT_FRONT_TEMP_INVERTER_FR_TEMP_NAME "INVERTER_FR_temp"
#define MCB_DSPACE_PWT_FRONT_TEMP_MOTOR_FR_TEMP_NAME "MOTOR_FR_temp"
#define MCB_DSPACE_PWT_REAR_TEMP_INVERTER_RL_TEMP_NAME "INVERTER_RL_temp"
#define MCB_DSPACE_PWT_REAR_TEMP_MOTOR_RL_TEMP_NAME "MOTOR_RL_temp"
#define MCB_DSPACE_PWT_REAR_TEMP_INVERTER_RR_TEMP_NAME "INVERTER_RR_temp"
#define MCB_DSPACE_PWT_REAR_TEMP_MOTOR_RR_TEMP_NAME "MOTOR_RR_temp"
#define MCB_DSPACE_XCP_TX_XCP_PAYLOAD_NAME "xcp_payload"
#define MCB_DSPACE_SIGNALS_HVBAT_SOC_NAME "HVBAT_soc"
#define MCB_DSPACE_FSM_STATES_DSPACE_MAIN_FSM_STATE_NAME "DSPACE_main_FSM_State"
#define MCB_DSPACE_FSM_STATES_DSPACE_AMK_INV_FL_FSM_STATE_NAME "DSPACE_amkInvFL_FSM_State"
#define MCB_DSPACE_FSM_STATES_DSPACE_AMK_INV_FR_FSM_STATE_NAME "DSPACE_amkInvFR_FSM_State"
#define MCB_DSPACE_FSM_STATES_DSPACE_AMK_INV_RL_FSM_STATE_NAME "DSPACE_amkInvRL_FSM_State"
#define MCB_DSPACE_FSM_STATES_DSPACE_AMK_INV_RR_FSM_STATE_NAME "DSPACE_amkInvRR_FSM_State"
#define MCB_DSPACE_HELLO_FW_MAJOR_VERSION_NAME "FW_majorVersion"
#define MCB_DSPACE_HELLO_FW_MINOR_VERSION_NAME "FW_minorVersion"
#define MCB_DSPACE_HELLO_FW_PATCH_VERSION_NAME "FW_patchVersion"
#define MCB_DSPACE_DASH_LEDS_COLOR_RGB_LED_1_RED_NAME "LED_1_red"
#define MCB_DSPACE_DASH_LEDS_COLOR_RGB_LED_1_GREEN_NAME "LED_1_green"
#define MCB_DSPACE_DASH_LEDS_COLOR_RGB_LED_1_BLUE_NAME "LED_1_blue"
#define MCB_DSPACE_DASH_LEDS_COLOR_RGB_LED_2_RED_NAME "LED_2_red"
#define MCB_DSPACE_DASH_LEDS_COLOR_RGB_LED_2_GREEN_NAME "LED_2_green"
#define MCB_DSPACE_DASH_LEDS_COLOR_RGB_LED_2_BLUE_NAME "LED_2_blue"
#define MCB_DSPACE_DASH_LEDS_COLOR_RGB_LED_3_RED_NAME "LED_3_red"
#define MCB_DSPACE_DASH_LEDS_COLOR_RGB_LED_3_GREEN_NAME "LED_3_green"
#define MCB_DSPACE_DASH_LEDS_COLOR_RGB_LED_3_BLUE_NAME "LED_3_blue"
#define MCB_DSPACE_DASH_LEDS_COLOR_RGB_LED_4_RED_NAME "LED_4_red"
#define MCB_DSPACE_DASH_LEDS_COLOR_RGB_LED_4_GREEN_NAME "LED_4_green"
#define MCB_DSPACE_DASH_LEDS_COLOR_RGB_LED_4_BLUE_NAME "LED_4_blue"
#define MCB_SCANNER_XCP_TX_XCP_PAYLOAD_NAME "xcp_payload"

/**
 * Signals in message IRTS_placeholderMessage.
 *
 * IRTS message placeholder TODO: update this message when you have the specification
 *
 * All signal values are as on the CAN bus.
 */
struct mcb_irts_placeholder_message_t {
    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint64_t irts_signal_placeholder;
};

/**
 * Signals in message SB_FRONT__analogDevice.
 *
 * (cycle_time: 10) (send_type: Cyclic)
 *
 * All signal values are as on the CAN bus.
 */
struct mcb_sb_front_analog_device_t {
    /**
     * The voltage of the APPS #0 expressed in mV
     *
     * Range: 0..65535 (0..65535 mV)
     * Scale: 1
     * Offset: 0
     */
    uint16_t apps_0_voltage;

    /**
     * The voltage of the APPS #1 expressed in mV
     *
     * Range: 0..65535 (0..65535 mV)
     * Scale: 1
     * Offset: 0
     */
    uint16_t apps_1_voltage;

    /**
     * The voltage of the Steering Wheel RME (rotary magnetic encoder) sensor expressed in mV
     *
     * Range: 0..65535 (0..65535 mV)
     * Scale: 1
     * Offset: 0
     */
    uint16_t steer_rme_voltage;

    /**
     * The voltage of the front brake pressure sensor expressed in mV
     *
     * Range: 0..8192 (0..8192 mV)
     * Scale: 1
     * Offset: 0
     */
    uint16_t brake_press_front_voltage;
};

/**
 * Signals in message SB_FRONT__SDCsensingStatus.
 *
 * (cycle_time: 10) (send_type: Cyclic)
 *
 * All signal values are as on the CAN bus.
 */
struct mcb_sb_front_sd_csensing_status_t {
    /**
     * States whether the SDC post inertia switch is active
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t sdc_post_inertia_is_active;

    /**
     * States whether the SDC post BOTS is active
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t sdc_post_bots_is_active;

    /**
     * States whether the SDC post cockpit push button is active
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t sdc_post_cp_push_btn_is_active;
};

/**
 * Signals in message SB_FRONT__potentiometer.
 *
 * (cycle_time: 10) (send_type: Cyclic)
 *
 * All signal values are as on the CAN bus.
 */
struct mcb_sb_front_potentiometer_t {
    /**
     * The voltage of the linear potentiometer position sensor on the front left damper expressed in mV
     *
     * Range: 0..65535 (0..65535 mV)
     * Scale: 1
     * Offset: 0
     */
    uint16_t lpps_damper_fl_voltage;

    /**
     * The voltage of the linear potentiometer position sensor on the front right damper expressed in mV
     *
     * Range: 0..65535 (0..65535 mV)
     * Scale: 1
     * Offset: 0
     */
    uint16_t lpps_damper_fr_voltage;
};

/**
 * Signals in message SB_FRONT__xcpTx.
 *
 * (send_type: CyclicIfActive)
 *
 * All signal values are as on the CAN bus.
 */
struct mcb_sb_front_xcp_tx_t {
    /**
     * xcp payload data
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint64_t xcp_payload;
};

/**
 * Signals in message SB_FRONT__hello.
 *
 * (send_type: IfActive)
 *
 * All signal values are as on the CAN bus.
 */
struct mcb_sb_front_hello_t {
    /**
     * firmware major version number
     *
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t fw_major_version;

    /**
     * firmware minor version number
     *
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t fw_minor_version;

    /**
     * firmware patch version number
     *
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t fw_patch_version;
};

/**
 * Signals in message SB_FRONT__ntcResistance.
 *
 * (cycle_time: 500) (send_type: Cyclic)
 *
 * All signal values are as on the CAN bus.
 */
struct mcb_sb_front_ntc_resistance_t {
    /**
     * The resistance of the front left jacket NTC expressed in Ohm
     *
     * Range: -32..991 (0..31968.75 Ohm)
     * Scale: 31.25
     * Offset: 1000
     */
    uint16_t jacket_fl_ntc_resistance;

    /**
     * The resistance of the front right jacket NTC expressed in Ohm
     *
     * Range: -32..991 (0..31968.75 Ohm)
     * Scale: 31.25
     * Offset: 1000
     */
    uint16_t jacket_fr_ntc_resistance;

    /**
     * The resistance of the left coldplate NTC expressed in Ohm
     *
     * Range: -32..991 (0..31968.75 Ohm)
     * Scale: 31.25
     * Offset: 1000
     */
    uint16_t coldplate_l_ntc_resistance;

    /**
     * The resistance of the right coldplate NTC expressed in Ohm
     *
     * Range: -32..991 (0..31968.75 Ohm)
     * Scale: 31.25
     * Offset: 1000
     */
    uint16_t coldplate_r_ntc_resistance;

    /**
     * The resistance of the spare NTC #0 expressed in Ohm
     *
     * Range: -32..991 (0..31968.75 Ohm)
     * Scale: 31.25
     * Offset: 1000
     */
    uint16_t spare_ntc_0_resistance;

    /**
     * The resistance of the spare NTC #1 expressed in Ohm
     *
     * Range: -32..991 (0..31968.75 Ohm)
     * Scale: 31.25
     * Offset: 1000
     */
    uint16_t spare_ntc_1_resistance;
};

/**
 * Signals in message SB_REAR__analogDevice.
 *
 * (cycle_time: 10) (send_type: Cyclic)
 *
 * All signal values are as on the CAN bus.
 */
struct mcb_sb_rear_analog_device_t {
    /**
     * The voltage of the left cooling pressure sensor expressed in mV
     *
     * Range: 0..65535 (0..65535 mV)
     * Scale: 1
     * Offset: 0
     */
    uint16_t cool_press_left_voltage;

    /**
     * The voltage of the right cooling pressure sensor expressed in mV
     *
     * Range: 0..65535 (0..65535 mV)
     * Scale: 1
     * Offset: 0
     */
    uint16_t cool_press_right_voltage;

    /**
     * The voltage of the rear brake pressure sensor expressed in mV
     *
     * Range: 0..65535 (0..65535 mV)
     * Scale: 1
     * Offset: 0
     */
    uint16_t brake_press_rear_voltage;
};

/**
 * Signals in message SB_REAR__criticalPeripherals.
 *
 * (cycle_time: 10) (send_type: Cyclic)
 *
 * All signal values are as on the CAN bus.
 */
struct mcb_sb_rear_critical_peripherals_t {
    /**
     * States whether the discharge is discharging the DCBUS
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t discharge_is_active;

    /**
     * States whether the BSPD has an error
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t bspd_has_error;
};

/**
 * Signals in message SB_REAR__SDCsensingStatus.
 *
 * (cycle_time: 10) (send_type: Cyclic)
 *
 * All signal values are as on the CAN bus.
 */
struct mcb_sb_rear_sd_csensing_status_t {
    /**
     * States whether the SDC post BSPD is closed
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t sdc_post_bspd_is_closed;

    /**
     * States whether the SDC per push buttons (hoop right/left) is closed
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t sdc_pre_push_btns_is_closed;

    /**
     * States whether the SDC post DC bus (inverter mono) is closed
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t sdc_post_dc_bus_is_closed;

    /**
     * States whether the SDC post inverter front right is closed
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t sdc_post_inv_fr_is_closed;
};

/**
 * Signals in message SB_REAR__potentiometer.
 *
 * (cycle_time: 10) (send_type: Cyclic)
 *
 * All signal values are as on the CAN bus.
 */
struct mcb_sb_rear_potentiometer_t {
    /**
     * The voltage of the linear potentiometer position sensor on the rear left damper expressed in mV
     *
     * Range: 0..65535 (0..65535 mV)
     * Scale: 1
     * Offset: 0
     */
    uint16_t lpps_damper_rl_voltage;

    /**
     * The voltage of the linear potentiometer position sensor on the rear left damper expressed in mV
     *
     * Range: 0..65535 (0..65535 mV)
     * Scale: 1
     * Offset: 0
     */
    uint16_t lpps_damper_rr_voltage;
};

/**
 * Signals in message SB_REAR__xcpTx.
 *
 * (send_type: CyclicIfActive)
 *
 * All signal values are as on the CAN bus.
 */
struct mcb_sb_rear_xcp_tx_t {
    /**
     * xcp payload data
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint64_t xcp_payload;
};

/**
 * Signals in message SB_REAR__hello.
 *
 * (send_type: IfActive)
 *
 * All signal values are as on the CAN bus.
 */
struct mcb_sb_rear_hello_t {
    /**
     * firmware major version number
     *
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t fw_major_version;

    /**
     * firmware minor version number
     *
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t fw_minor_version;

    /**
     * firmware patch version number
     *
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t fw_patch_version;
};

/**
 * Signals in message SB_REAR__ntcResistance.
 *
 * (cycle_time: 500) (send_type: Cyclic)
 *
 * All signal values are as on the CAN bus.
 */
struct mcb_sb_rear_ntc_resistance_t {
    /**
     * The resistance of the rear left jacket NTC expressed in Ohm
     *
     * Range: -32..991 (0..31968.75 Ohm)
     * Scale: 31.25
     * Offset: 1000
     */
    uint16_t jacket_rl_ntc_resistance;

    /**
     * The resistance of the rear right jacket NTC expressed in Ohm
     *
     * Range: -32..991 (0..31968.75 Ohm)
     * Scale: 31.25
     * Offset: 1000
     */
    uint16_t jacket_rr_ntc_resistance;

    /**
     * The resistance of the rear left IN radiator NTC expressed in Ohm
     *
     * Range: -32..991 (0..31968.75 Ohm)
     * Scale: 31.25
     * Offset: 1000
     */
    uint16_t rad_rl_in_ntc_resistance;

    /**
     * The resistance of the rear left OUT radiator NTC expressed in Ohm
     *
     * Range: -32..991 (0..31968.75 Ohm)
     * Scale: 31.25
     * Offset: 1000
     */
    uint16_t rad_rl_out_ntc_resistance;

    /**
     * The resistance of the rear right IN radiator NTC expressed in Ohm
     *
     * Range: -32..991 (0..31968.75 Ohm)
     * Scale: 31.25
     * Offset: 1000
     */
    uint16_t rad_rr_in_ntc_resistance;

    /**
     * The resistance of the rear right OUT radiator NTC expressed in Ohm
     *
     * Range: -32..991 (0..31968.75 Ohm)
     * Scale: 31.25
     * Offset: 1000
     */
    uint16_t rad_rr_out_ntc_resistance;
};

/**
 * Signals in message TLB_BAT__signalsStatus.
 *
 * (cycle_time: 10) (send_type: Cyclic)
 *
 * All signal values are as on the CAN bus.
 */
struct mcb_tlb_bat_signals_status_t {
    /**
     * Status of the Positive AIR command
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t air_pos_cmd_is_active;

    /**
     * Status of the Positive AIR mechanical state
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t air_pos_is_closed;

    /**
     * Status of the Negative AIR command
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t air_neg_cmd_is_active;

    /**
     * Status of the Negative AIR mechanical state
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t air_neg_is_closed;

    /**
     * Status of the DCBUS Precharge Relay command
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dcbus_prech_rly_cmd_is_active;

    /**
     * Status of the DCBUS Precharge Relay mechanical state
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dcbus_prech_rly_is_closed;

    /**
     * States whether the AMS error is active
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t ams_err_is_active;

    /**
     * States whether the IMD error is active
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t imd_err_is_active;

    /**
     * States whether the TSAL green signal is active
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t tsal_green_is_active;

    /**
     * States whether the DC BUS volatge is over 60V
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dcbus_is_over60_v;

    /**
     * States whether any implausibility is active
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t imp_any_is_active;

    /**
     * States whether an implausibility on HV relays (NEG,POS,PRECH) State is active (differene between cmd and mechanical state)
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t imp_hv_relays_state_is_active;

    /**
     * States whether the DCBUS Implausibility is active (DCBUS Less then 60V and TS is active)
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t imp_dcbus_is_active;

    /**
     * States whether a Short To Gnd on AIR POS mechanical state signal is active
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t air_pos_stg_mech_state_signal_is_active;

    /**
     * States whether a Short To Gnd on AIR NEG mechanical state signal is active
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t air_neg_stg_mech_state_signal_is_active;
};

/**
 * Signals in message TLB_BAT__SDCsensingStatus.
 *
 * (cycle_time: 10) (send_type: Cyclic)
 *
 * All signal values are as on the CAN bus.
 */
struct mcb_tlb_bat_sd_csensing_status_t {
    /**
     * Shutdown Circuit sensing: TSAC Initial input is active status
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t sdc_tsac_initial_in_is_active;

    /**
     * Shutdown Circuit sensing: post AMS/IMD relay is active status
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t sdc_post_ams_imd_relay_is_active;

    /**
     * Shutdown Circuit sensing: TSAC Final Input is active status
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t sdc_tsac_final_in_is_active;

    /**
     * States whether the SDC precharge bypass relay is closed
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t sdc_prech_bypass_relay_is_closed;

    /**
     * Shutdown Circuit sensing: TSAC Initial Input voltage
     *
     * Range: 0..1441 (0..255 V)
     * Scale: 0.177
     * Offset: 0
     */
    uint8_t sdc_tsac_initial_in_voltage;

    /**
     * Shutdown Circuit sensing: TSAC Final Input voltage
     *
     * Range: 0..1441 (0..255 V)
     * Scale: 0.177
     * Offset: 0
     */
    uint8_t sdc_tsac_final_in_voltage;
};

/**
 * Signals in message TLB_BAT__xcpTx.
 *
 * (send_type: CyclicIfActive)
 *
 * All signal values are as on the CAN bus.
 */
struct mcb_tlb_bat_xcp_tx_t {
    /**
     * xcp payload data
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint64_t xcp_payload;
};

/**
 * Signals in message TLB_BAT__hello.
 *
 * (send_type: IfActive)
 *
 * All signal values are as on the CAN bus.
 */
struct mcb_tlb_bat_hello_t {
    /**
     * firmware major version number
     *
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t fw_major_version;

    /**
     * firmware minor version number
     *
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t fw_minor_version;

    /**
     * firmware patch version number
     *
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t fw_patch_version;
};

/**
 * Signals in message IMU__Accelerometers.
 *
 * All signal values are as on the CAN bus.
 */
struct mcb_imu_accelerometers_t {
    /**
     * Range: -32768..32767 (-327.68..327.67 m.s-2)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t accel_x;

    /**
     * Range: -32768..32767 (-327.68..327.67 m.s-2)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t accel_y;

    /**
     * Range: -32768..32767 (-327.68..327.67 m.s-2)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t accel_z;
};

/**
 * Signals in message IMU__Gyro.
 *
 * All signal values are as on the CAN bus.
 */
struct mcb_imu_gyro_t {
    /**
     * Range: -32768..32767 (-32.768..32.767 rad.s-1)
     * Scale: 0.001
     * Offset: 0
     */
    int16_t gyro_x;

    /**
     * Range: -32768..32767 (-32.768..32.767 rad.s-1)
     * Scale: 0.001
     * Offset: 0
     */
    int16_t gyro_y;

    /**
     * Range: -32768..32767 (-32.768..32.767 rad.s-1)
     * Scale: 0.001
     * Offset: 0
     */
    int16_t gyro_z;
};

/**
 * Signals in message IMU__Euler.
 *
 * All signal values are as on the CAN bus.
 */
struct mcb_imu_euler_t {
    /**
     * Range: -32768..32767 (-3.2768..3.2767 rad)
     * Scale: 0.0001
     * Offset: 0
     */
    int16_t roll;

    /**
     * Range: -32768..32767 (-3.2768..3.2767 rad)
     * Scale: 0.0001
     * Offset: 0
     */
    int16_t pitch;

    /**
     * Range: -32768..32767 (-3.2768..3.2767 rad)
     * Scale: 0.0001
     * Offset: 0
     */
    int16_t yaw;
};

/**
 * Signals in message IMU__GPS1_Position.
 *
 * All signal values are as on the CAN bus.
 */
struct mcb_imu_gps1_position_t {
    /**
     * Range: -2147483648..2147483647 (-214.74836..214.74836 )
     * Scale: 1e-07
     * Offset: 0
     */
    int32_t latitude;

    /**
     * Range: -2147483648..2147483647 (-214.74836..214.74836 )
     * Scale: 1e-07
     * Offset: 0
     */
    int32_t longitude;
};

/**
 * Signals in message IMU__VelocityBody.
 *
 * All signal values are as on the CAN bus.
 */
struct mcb_imu_velocity_body_t {
    /**
     * Range: -32768..32767 (-327.68..327.67 m.s-1)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t velocity_x;

    /**
     * Range: -32768..32767 (-327.68..327.67 m.s-1)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t velocity_y;

    /**
     * Range: -32768..32767 (-327.68..327.67 m.s-1)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t velocity_z;
};

/**
 * Signals in message IMU__TrackSlipCurv.
 *
 * All signal values are as on the CAN bus.
 */
struct mcb_imu_track_slip_curv_t {
    /**
     * Range: -32768..32767 (-3.2768..3.2767 rad)
     * Scale: 0.0001
     * Offset: 0
     */
    int16_t angle_track;

    /**
     * Range: -32768..32767 (-3.2768..3.2767 rad)
     * Scale: 0.0001
     * Offset: 0
     */
    int16_t angle_slip;

    /**
     * Range: 0..65535 (0..655.35 m)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t curvature_radius;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t auto_status;
};

/**
 * Signals in message TPMS__frontWheelsPressure.
 *
 * (send_type: CyclicIfActive)
 *
 * All signal values are as on the CAN bus.
 */
struct mcb_tpms_front_wheels_pressure_t {
    /**
     * The sensor id of the Front Left tire
     *
     * Range: 1..255 (1..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t tire_fl_sens_id;

    /**
     * Acc bit of Front Left tire status register: wheel is spinning (1) or not (0)
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t tire_fl_status_is_spinning;

    /**
     * Vbatt bit of Front Left tire status register: TPMS battery is below 2.2V (1) or above (0)
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t tire_fl_status_is_vbatt_not_ok;

    /**
     * The temperature of the Front Left tire
     *
     * Range: 60..220 (10..170 degC)
     * Scale: 1
     * Offset: -50
     */
    uint8_t tire_fl_temperature;

    /**
     * The pressure of the front left tire
     *
     * Range: 0..19 (1..254 mB)
     * Scale: 13.7035
     * Offset: -0.7035
     */
    uint8_t tire_fl_pressure;

    /**
     * The sensor id of the front right tire
     *
     * Range: 1..255 (1..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t tire_fr_sens_id;

    /**
     * Acc bit of Front Right tire status register: wheel is spinning (1) or not (0)
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t tire_fr_status_is_spinning;

    /**
     * Vbatt bit of Front Right tire status register: TPMS battery is below 2.2V (1) or above (0)
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t tire_fr_status_is_vbatt_not_ok;

    /**
     * The temperature of the Front Right tire
     *
     * Range: 60..220 (10..170 degC)
     * Scale: 1
     * Offset: -50
     */
    uint8_t tire_fr_temperature;

    /**
     * The pressure of the Front Right tire
     *
     * Range: 0..19 (1..254 mB)
     * Scale: 13.7035
     * Offset: -0.7035
     */
    uint8_t tire_fr_pressure;
};

/**
 * Signals in message TPMS__rearWheelsPressure.
 *
 * (send_type: CyclicIfActive)
 *
 * All signal values are as on the CAN bus.
 */
struct mcb_tpms_rear_wheels_pressure_t {
    /**
     * The sensor id of the Rear Left tire
     *
     * Range: 1..255 (1..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t tire_rl_sens_id;

    /**
     * Acc bit of Rear Left tire status register: wheel is spinning (1) or not (0)
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t tire_rl_status_is_spinning;

    /**
     * Vbatt bit of Rear Left tire status register: TPMS battery is below 2.2V (1) or above (0)
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t tire_rl_status_is_vbatt_not_ok;

    /**
     * The temperature of the Rear Left tire
     *
     * Range: 60..220 (10..170 degC)
     * Scale: 1
     * Offset: -50
     */
    uint8_t tire_rl_temperature;

    /**
     * The pressure of the front left tire
     *
     * Range: 0..19 (1..254 mB)
     * Scale: 13.7035
     * Offset: -0.7035
     */
    uint8_t tire_rl_pressure;

    /**
     * The sensor id of the front right tire
     *
     * Range: 1..255 (1..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t tire_rr_sens_id;

    /**
     * Acc bit of Rear Right tire status register: wheel is spinning (1) or not (0)
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t tire_rr_status_is_spinning;

    /**
     * Vbatt bit of Rear Right tire status register: TPMS battery is below 2.2V (1) or above (0)
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t tire_rr_status_is_vbatt_not_ok;

    /**
     * The temperature of the Rear Right tire
     *
     * Range: 60..220 (10..170 degC)
     * Scale: 1
     * Offset: -50
     */
    uint8_t tire_rr_temperature;

    /**
     * The pressure of the Rear Right tire
     *
     * Range: 0..19 (1..254 mB)
     * Scale: 13.7035
     * Offset: -0.7035
     */
    uint8_t tire_rr_pressure;
};

/**
 * Signals in message NLG5_ST.
 *
 * (cycle_time: 100)
 *
 * All signal values are as on the CAN bus.
 */
struct mcb_nlg5_st_t {
    /**
     * Indicates if hardware enabled, i.e. a hi or lo signal is fed to the 'Power On' pin (pin3 of control connector)
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_s_he;

    /**
     * An error has been detected, red LED is ON, no power is output
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_s_err;

    /**
     * Warning condition on, i.e. charging power limited due to any limiting condition; red LED is blinking
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_s_war;

    /**
     * Charger cooling fan is active
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_s_fan;

    /**
     * European mains input detected (230V, 50Hz)
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_s_eum;

    /**
     * US mains level 1 (120VAC / 60Hz) detected
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_s_um_i;

    /**
     * US mains level 2 (240VAC / 60Hz) detected
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_s_um_ii;

    /**
     * Control pilot signal (SAE J1772) detected
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_s_cp_dt;

    /**
     * Bypass detection bit 1; 00: no bypass, 01: DC bypass detected, 10:AC bypass in phase, 11: AC bypass not in phase
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_s_bpd_i;

    /**
     * Bypass detection bit 2; 00: no bypass, 01: DC bypass detected, 10:AC bypass in phase, 11: AC bypass not in phase
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_s_bpd_ii;

    /**
     * Output power limited by battery output voltage limit
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_s_l_ov;

    /**
     * Output power limited by battery output current limit
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_s_l_oc;

    /**
     * Output power limited by mains current limit
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_s_l_mc;

    /**
     * Output power limited by analog input 'power indicator' (PI) limit
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_s_l_pi;

    /**
     * Output power limited by control pilot signal (SAE J1772)
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_s_l_cp;

    /**
     * Output power limited by maximum power capability of NLG5
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_s_l_pmax;

    /**
     * Output power limited by maximum mains current capability of NLG5
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_s_l_mc_max;

    /**
     * Output power limited by maximum output current capability of NLG5
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_s_l_oc_max;

    /**
     * Output power limited by maximum output voltage capability of NLG5
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_s_l_mo_max;

    /**
     * Output power limited by temperature of primary capacitors
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_s_l_t_cprim;

    /**
     * Output power limited by temperature of power stage
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_s_l_t_pow;

    /**
     * Output power limited by temperature of diodes
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_s_l_t_dio;

    /**
     * Output power limited by temperature of transformer
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_s_l_t_tr;

    /**
     * Output power limited by battery temperature
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_s_l_t_batt;

    /**
     * AUX 12 V Automatic Charging Active
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_s_aac;
};

/**
 * Signals in message NLG5_ACT_I.
 *
 * (cycle_time: 100)
 *
 * All signal values are as on the CAN bus.
 */
struct mcb_nlg5_act_i_t {
    /**
     * Actual mains current
     *
     * Range: 0..5000 (0..50 A)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t nlg5_mc_act;

    /**
     * Actual mains voltage
     *
     * Range: 0..5000 (0..500 V)
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t nlg5_mv_act;

    /**
     * Actual battery output voltage
     *
     * Range: 0..10000 (0..1000 V)
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t nlg5_ov_act;

    /**
     * output current to the battery
     *
     * Range: 0..15000 (0..150 A)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t nlg5_oc_act;
};

/**
 * Signals in message NLG5_ACT_II.
 *
 * (cycle_time: 100)
 *
 * All signal values are as on the CAN bus.
 */
struct mcb_nlg5_act_ii_t {
    /**
     * Value of mains current limit, commanded by the control pilot (SAE J1772) signal
     *
     * Range: 0..1000 (0..100 A)
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t nlg5_s_mc_m_cp;

    /**
     * Value of mains current limit, commanded by the 'power indicator' (PI) analog input signal
     *
     * Range: 0..200 (0..20 A)
     * Scale: 0.1
     * Offset: 0
     */
    uint8_t nlg5_s_mc_m_pi;

    /**
     * Aux battery voltage
     *
     * Range: 0..250 (0..25 V)
     * Scale: 0.1
     * Offset: 0
     */
    uint8_t nlg5_abv;

    /**
     * Charge balance obtained via  Ext. Ah counter connected to DI1 / DI2
     *
     * Range: -32768..32767 (-327.68..327.67 Ah)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t nlg5_ahc_ext;

    /**
     * output current of the booster (if one is present and active)
     *
     * Range: 0..5000 (0..50 A)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t nlg5_oc_bo;
};

/**
 * Signals in message NLG5_TEMP.
 *
 * (cycle_time: 1000)
 *
 * All signal values are as on the CAN bus.
 */
struct mcb_nlg5_temp_t {
    /**
     * Power stage temperature
     *
     * Range: -400..3000 (-40..300 degC)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t nlg5_p_tmp;

    /**
     * Value of external battery temperature sensor #1 (if connected and enabled)
     *
     * Range: -400..3000 (-40..300 degC)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t nlg5_tmp_ext1;

    /**
     * Value of external battery temperature sensor #2 (if connected and enabled)
     *
     * Range: -400..3000 (-40..300 degC)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t nlg5_temp_ext2;

    /**
     * Value of external battery temperature sensor #3 (if connected and enabled)
     *
     * Range: -400..3000 (-40..300 degC)
     * Scale: 0.1
     * Offset: 0
     */
    int16_t nlg5_tmp_ext3;
};

/**
 * Signals in message NLG5_ERR.
 *
 * (cycle_time: 1000)
 *
 * All signal values are as on the CAN bus.
 */
struct mcb_nlg5_err_t {
    /**
     * battery output overvoltage; error can only be cleared by cycling power ON-OFF-ON
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_e_oov;

    /**
     * Mains overvoltage 2 detected
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_e_mov_ii;

    /**
     * Mains overvoltage 1 detected
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_e_mov_i;

    /**
     * power stage short circuit condition detected; error can only be cleared by cycling power ON-OFF-ON
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_e_sc;

    /**
     * plausibility battery output voltage measurement wrong
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_e_p_om;

    /**
     * plausibility mains voltage measurement wrong
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_e_p_mv;

    /**
     * output fuse defective
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_e_of;

    /**
     * Mains fuse defective
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_e_mf;

    /**
     * wrong battery polarity;  error can only be cleared by cycling power ON-OFF-ON
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_e_b_p;

    /**
     * Temperature sensor for prim capacitor defective
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_e_t_c;

    /**
     * Temperature sensor for prim power stage defective
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_e_t_pow;

    /**
     * Temperature sensor for diodes defective
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_e_t_dio;

    /**
     * Temperature sensor for transformer defective
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_e_t_tr;

    /**
     * Ext. temperature sensor 1 defective (if enabled)
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_e_t_ext1;

    /**
     * Ext. temperature sensor 2 defective (if enabled)
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_e_t_ext2;

    /**
     * Ext. temperature sensor 3 defective (if enabled)
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_e_t_ext3;

    /**
     * Flash memory checksum failure
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_e_f_crc;

    /**
     * NVSRAM check sum failure; contains most of the scaling & calibration values, CAN ID's and  charging profile etc.
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_e_nv_crc;

    /**
     * Sys EEPROM checksum failure
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_e_es_crc;

    /**
     * Pow EEPROM checksum failure
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_e_ep_crc;

    /**
     * Internal Watchdog Timeout
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_e_wdt;

    /**
     * Initialization error
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_e_init;

    /**
     * CAN timeout, no control message received for >300ms
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_e_c_to;

    /**
     * CAN off, transmit buffer >255
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_e_c_off;

    /**
     * CAN transmit buffer >127
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_e_c_tx;

    /**
     * CAN receiver buffer >127
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_e_c_rx;

    /**
     * Emergency Shutdown Threshold 'Battery Temperature' is exceeded; see ChargeStar help section 'protective features';  error can only be cleared by cycling power ON-OFF-ON
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_e_sdt_bt;

    /**
     * Emergency Shutdown Threshold 'Battery Voltage' is exceeded; see ChargeStar help section 'protective features';  error can only be cleared by cycling power ON-OFF-ON
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_e_sdt_bv;

    /**
     * Emergency Shutdown Threshold 'Amp Hours' is exceeded; see ChargeStar help section 'protective features';  error can only be cleared by cycling power ON-OFF-ON
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_e_sdt_ah;

    /**
     * Emergency Shutdown Threshold 'Charging Time' is exceeded; see ChargeStar help section 'protective features';  error can only be cleared by cycling power ON-OFF-ON
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_e_sdt_ct;

    /**
     * Output power limited by low mains voltage
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_w_pl_mv;

    /**
     * Output power limited by low battery voltage
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_w_pl_bv;

    /**
     * Output power limited by charger internal overtemperature
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_w_pl_it;

    /**
     * Commanded value is out of specified range; max or min applicable value is assumed instead
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_w_c_vor;

    /**
     * NLG5 Control message not active
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_w_cm_na;

    /**
     * LED Output driver defective, LEDs cannot be controlled by NLG5 anymore. Charging is still possible.
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_w_od;

    /**
     * Save-Charging-Mode reduces primary current to 3.95 A as long as one of the four internal temperature sensors indicates -18deg C or less.
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_w_sc_m;
};

/**
 * Signals in message NLG5_CTL.
 *
 * (cycle_time: 100)
 *
 * All signal values are as on the CAN bus.
 */
struct mcb_nlg5_ctl_t {
    /**
     * Must be ON to enable power stage of the charger
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_c_c_en;

    /**
     * cycle this value 0-1-0 to clear all latched charger errors
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_c_c_el;

    /**
     * special signal to tell a charging station equipped with the Control Pilot interface (SAE J1772) to switch on the facility's ventilation (in order to get rid of battery gases like hydrogen, e.g.)
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_c_cp_v;

    /**
     * Enables CP-State C to request mains voltage
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t nlg5_c_mr;

    /**
     * Maximum current to be drawn from the mains outlet, usually 16A. Must always contain a valid value in order to keep on charging.
     *
     * Range: 0..500 (0..50 A)
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t nlg5_mc_max;

    /**
     * Desired voltage to be output to the battery. Must always contain a valid value in order to keep on charging.
     *
     * Range: 0..10000 (0..1000 V)
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t nlg5_ov_com;

    /**
     * Desired battery current. Must always contain a valid value in order to keep on charging.
     *
     * Range: 0..1500 (0..150 A)
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t nlg5_oc_com;
};

/**
 * Signals in message NLG5_DIAG_RX.
 *
 * All signal values are as on the CAN bus.
 */
struct mcb_nlg5_diag_rx_t {
    /**
     * Diag requested data from host
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint64_t lad_d_param_rq;
};

/**
 * Signals in message NLG5_DIAG_TX.
 *
 * All signal values are as on the CAN bus.
 */
struct mcb_nlg5_diag_tx_t {
    /**
     * Diag responded data to host
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint64_t lad_d_param_rp;
};

/**
 * Signals in message BMS_LV__lvBatGeneral.
 *
 * (cycle_time: 100) (send_type: Cyclic)
 *
 * All signal values are as on the CAN bus.
 */
struct mcb_bms_lv_lv_bat_general_t {
    /**
     * The voltage returned by the current sensor of the LV battery expressed in mV
     *
     * Range: 0..65535 (0..4980.66 mV)
     * Scale: 0.076
     * Offset: 0
     */
    uint16_t lv_bat_current_sens_voltage;

    /**
     * The total read voltage of the LV battery pack expressed in mV
     *
     * Range: -52434..13101 (0..17497.845 mV)
     * Scale: 0.267
     * Offset: 14000
     */
    uint16_t lv_bat_voltage;

    /**
     * The total voltage of the LV battery pack calculated by summing each cell voltage expressed in mV
     *
     * Range: -52434..13101 (0..17497.845 mV)
     * Scale: 0.267
     * Offset: 14000
     */
    uint16_t lv_bat_summed_voltage;
};

/**
 * Signals in message BMS_LV__xcpTx.
 *
 * (send_type: CyclicIfActive)
 *
 * All signal values are as on the CAN bus.
 */
struct mcb_bms_lv_xcp_tx_t {
    /**
     * xcp payload data
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint64_t xcp_payload;
};

/**
 * Signals in message BMS_LV__cellsStatus.
 *
 * (cycle_time: 100) (send_type: Cyclic)
 *
 * All signal values are as on the CAN bus.
 */
struct mcb_bms_lv_cells_status_t {
    /**
     * States whether the LV cell #0 is in overvoltage
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t lv_cell_0_is_ov;

    /**
     * States whether the LV cell #0 is in undervoltage
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t lv_cell_0_is_uv;

    /**
     * States whether the LV cell #1 is in overvoltage
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t lv_cell_1_is_ov;

    /**
     * States whether the LV cell #1 is in undervoltage
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t lv_cell_1_is_uv;

    /**
     * States whether the LV cell #2 is in overvoltage
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t lv_cell_2_is_ov;

    /**
     * States whether the LV cell #2 is in undervoltage
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t lv_cell_2_is_uv;

    /**
     * States whether the LV cell #3 is in overvoltage
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t lv_cell_3_is_ov;

    /**
     * States whether the LV cell #3 is in undervoltage
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t lv_cell_3_is_uv;

    /**
     * States whether the LV cell #4 is in overvoltage
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t lv_cell_4_is_ov;

    /**
     * States whether the LV cell #4 is in undervoltage
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t lv_cell_4_is_uv;

    /**
     * States whether the LV cell #5 is in overvoltage
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t lv_cell_5_is_ov;

    /**
     * States whether the LV cell #5 is in undervoltage
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t lv_cell_5_is_uv;

    /**
     * States whether the LV cell #6 is in overvoltage
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t lv_cell_6_is_ov;

    /**
     * States whether the LV cell #6 is in undervoltage
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t lv_cell_6_is_uv;

    /**
     * States whether the LV cell temperature sensor #0 (NTC) detects an over temperature
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t lv_cell_ntc_00_is_ot;

    /**
     * States whether the LV cell temperature sensor #1 (NTC) detects an over temperature
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t lv_cell_ntc_01_is_ot;

    /**
     * States whether the LV cell temperature sensor #2 (NTC) detects an over temperature
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t lv_cell_ntc_02_is_ot;

    /**
     * States whether the LV cell temperature sensor #3 (NTC) detects an over temperature
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t lv_cell_ntc_03_is_ot;

    /**
     * States whether the LV cell temperature sensor #4 (NTC) detects an over temperature
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t lv_cell_ntc_04_is_ot;

    /**
     * States whether the LV cell temperature sensor #5 (NTC) detects an over temperature
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t lv_cell_ntc_05_is_ot;

    /**
     * States whether the LV cell temperature sensor #6 (NTC) detects an over temperature
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t lv_cell_ntc_06_is_ot;

    /**
     * States whether the LV cell temperature sensor #7 (NTC) detects an over temperature
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t lv_cell_ntc_07_is_ot;

    /**
     * States whether the LV cell temperature sensor #8 (NTC) detects an over temperature
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t lv_cell_ntc_08_is_ot;

    /**
     * States whether the LV cell temperature sensor #9 (NTC) detects an over temperature
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t lv_cell_ntc_09_is_ot;

    /**
     * States whether the LV cell temperature sensor #10 (NTC) detects an over temperature
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t lv_cell_ntc_10_is_ot;

    /**
     * States whether the LV cell temperature sensor #11 (NTC) detects an over temperature
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t lv_cell_ntc_11_is_ot;
};

/**
 * Signals in message BMS_LV__status.
 *
 * (cycle_time: 500) (send_type: Cyclic)
 *
 * All signal values are as on the CAN bus.
 */
struct mcb_bms_lv_status_t {
    /**
     * States whether the LV relay is closed
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t lv_relay_is_closed;

    /**
     * States whether the LV relay override is enabled
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t lv_relay_is_relay_override_on;
};

/**
 * Signals in message BMS_LV__lvCellVoltage0.
 *
 * (cycle_time: 100) (send_type: Cyclic)
 *
 * All signal values are as on the CAN bus.
 */
struct mcb_bms_lv_lv_cell_voltage0_t {
    /**
     * The voltage of the LV cell #0 expressed in mV
     *
     * Range: -52632..12903 (0..2490.33 mV)
     * Scale: 0.038
     * Offset: 2000
     */
    uint16_t lv_cell_0_voltage;

    /**
     * The voltage of the LV cell #1 expressed in mV
     *
     * Range: -52632..12903 (0..2490.33 mV)
     * Scale: 0.038
     * Offset: 2000
     */
    uint16_t lv_cell_1_voltage;

    /**
     * The voltage of the LV cell #2 expressed in mV
     *
     * Range: -52632..12903 (0..2490.33 mV)
     * Scale: 0.038
     * Offset: 2000
     */
    uint16_t lv_cell_2_voltage;

    /**
     * The voltage of the LV cell #3 expressed in mV
     *
     * Range: -52632..12903 (0..2490.33 mV)
     * Scale: 0.038
     * Offset: 2000
     */
    uint16_t lv_cell_3_voltage;
};

/**
 * Signals in message BMS_LV__lvCellVoltage1.
 *
 * (cycle_time: 100) (send_type: Cyclic)
 *
 * All signal values are as on the CAN bus.
 */
struct mcb_bms_lv_lv_cell_voltage1_t {
    /**
     * The voltage of the LV cell #4 expressed in mV
     *
     * Range: -52632..12903 (0..2490.33 mV)
     * Scale: 0.038
     * Offset: 2000
     */
    uint16_t lv_cell_4_voltage;

    /**
     * The voltage of the LV cell #4 expressed in mV
     *
     * Range: -52632..12903 (0..2490.33 mV)
     * Scale: 0.038
     * Offset: 2000
     */
    uint16_t lv_cell_5_voltage;

    /**
     * The voltage of the LV cell #4 expressed in mV
     *
     * Range: -52632..12903 (0..2490.33 mV)
     * Scale: 0.038
     * Offset: 2000
     */
    uint16_t lv_cell_6_voltage;
};

/**
 * Signals in message BMS_LV__hello.
 *
 * (send_type: IfActive)
 *
 * All signal values are as on the CAN bus.
 */
struct mcb_bms_lv_hello_t {
    /**
     * firmware major version number
     *
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t fw_major_version;

    /**
     * firmware minor version number
     *
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t fw_minor_version;

    /**
     * firmware patch version number
     *
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t fw_patch_version;
};

/**
 * Signals in message BMS_LV__lvCellNTCResistance0.
 *
 * (cycle_time: 2000) (send_type: Cyclic)
 *
 * All signal values are as on the CAN bus.
 */
struct mcb_bms_lv_lv_cell_ntc_resistance0_t {
    /**
     * The resistance of the NTC #0 in the battery pack expressed in Ohm
     *
     * Range: -32..991 (0..31968.75 Ohm)
     * Scale: 31.25
     * Offset: 1000
     */
    uint16_t lv_cell_ntc_00_resistance;

    /**
     * The resistance of the NTC #1 in the battery pack expressed in Ohm
     *
     * Range: -32..991 (0..31968.75 Ohm)
     * Scale: 31.25
     * Offset: 1000
     */
    uint16_t lv_cell_ntc_01_resistance;

    /**
     * The resistance of the NTC #2 in the battery pack expressed in Ohm
     *
     * Range: -32..991 (0..31968.75 Ohm)
     * Scale: 31.25
     * Offset: 1000
     */
    uint16_t lv_cell_ntc_02_resistance;

    /**
     * The resistance of the NTC #3 in the battery pack expressed in Ohm
     *
     * Range: -32..991 (0..31968.75 Ohm)
     * Scale: 31.25
     * Offset: 1000
     */
    uint16_t lv_cell_ntc_03_resistance;

    /**
     * The resistance of the NTC #4 in the battery pack expressed in Ohm
     *
     * Range: -32..991 (0..31968.75 Ohm)
     * Scale: 31.25
     * Offset: 1000
     */
    uint16_t lv_cell_ntc_04_resistance;

    /**
     * The resistance of the NTC #5 in the battery pack expressed in Ohm
     *
     * Range: -32..991 (0..31968.75 Ohm)
     * Scale: 31.25
     * Offset: 1000
     */
    uint16_t lv_cell_ntc_05_resistance;
};

/**
 * Signals in message BMS_LV__lvCellNTCResistance1.
 *
 * (cycle_time: 2000) (send_type: Cyclic)
 *
 * All signal values are as on the CAN bus.
 */
struct mcb_bms_lv_lv_cell_ntc_resistance1_t {
    /**
     * The resistance of the NTC #6 in the battery pack expressed in Ohm
     *
     * Range: -32..991 (0..31968.75 Ohm)
     * Scale: 31.25
     * Offset: 1000
     */
    uint16_t lv_cell_ntc_06_resistance;

    /**
     * The resistance of the NTC #7 in the battery pack expressed in Ohm
     *
     * Range: -32..991 (0..31968.75 Ohm)
     * Scale: 31.25
     * Offset: 1000
     */
    uint16_t lv_cell_ntc_07_resistance;

    /**
     * The resistance of the NTC #8 in the battery pack expressed in Ohm
     *
     * Range: -32..991 (0..31968.75 Ohm)
     * Scale: 31.25
     * Offset: 1000
     */
    uint16_t lv_cell_ntc_08_resistance;

    /**
     * The resistance of the NTC #9 in the battery pack expressed in Ohm
     *
     * Range: -32..991 (0..31968.75 Ohm)
     * Scale: 31.25
     * Offset: 1000
     */
    uint16_t lv_cell_ntc_09_resistance;

    /**
     * The resistance of the NTC #10 in the battery pack expressed in Ohm
     *
     * Range: -32..991 (0..31968.75 Ohm)
     * Scale: 31.25
     * Offset: 1000
     */
    uint16_t lv_cell_ntc_10_resistance;

    /**
     * The resistance of the NTC #11 in the battery pack expressed in Ohm
     *
     * Range: -32..991 (0..31968.75 Ohm)
     * Scale: 31.25
     * Offset: 1000
     */
    uint16_t lv_cell_ntc_11_resistance;
};

/**
 * Signals in message DASH__hmiDevicesState.
 *
 * (cycle_time: 200) (send_type: Cyclic)
 *
 * All signal values are as on the CAN bus.
 */
struct mcb_dash_hmi_devices_state_t {
    /**
     * Steering wheel Button #1 is pressed
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t btn_1_is_pressed;

    /**
     * Steering wheel Button #2 is pressed
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t btn_2_is_pressed;

    /**
     * Steering wheel Button #3 is pressed
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t btn_3_is_pressed;

    /**
     * Steering wheel Button #4 is pressed
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t btn_4_is_pressed;

    /**
     * Steering wheel Button #5 is pressed
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t btn_5_is_pressed;

    /**
     * Rotary Switch 1 state
     *
     * Range: 0..9 (0..9 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t rot_sw_1_state;

    /**
     * Rotary Switch 2 state
     *
     * Range: 0..9 (0..9 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t rot_sw_2_state;

    /**
     * Rotary Switch 3 state
     *
     * Range: 0..9 (0..9 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t rot_sw_3_state;
};

/**
 * Signals in message DASH__xcpTx.
 *
 * (send_type: CyclicIfActive)
 *
 * All signal values are as on the CAN bus.
 */
struct mcb_dash_xcp_tx_t {
    /**
     * xcp payload data
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint64_t xcp_payload;
};

/**
 * Signals in message DASH__peripheralsStatus.
 *
 * (cycle_time: 500) (send_type: Cyclic)
 *
 * All signal values are as on the CAN bus.
 */
struct mcb_dash_peripherals_status_t {
    /**
     * PWM duty cycle percentage for TSAC fans control
     *
     * Range: 0..10 (0..10 %)
     * Scale: 1
     * Offset: 0
     */
    uint8_t tsac_fan_pwm_duty_cycle_status;
};

/**
 * Signals in message DASH__hello.
 *
 * (send_type: IfActive)
 *
 * All signal values are as on the CAN bus.
 */
struct mcb_dash_hello_t {
    /**
     * firmware major version number
     *
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t fw_major_version;

    /**
     * firmware minor version number
     *
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t fw_minor_version;

    /**
     * firmware patch version number
     *
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t fw_patch_version;
};

/**
 * Signals in message DASH__appsRangeLimits.
 *
 * (send_type: IfActive)
 *
 * All signal values are as on the CAN bus.
 */
struct mcb_dash_apps_range_limits_t {
    /**
     * APPS channel #0 minimum range expressed in mV
     *
     * Range: 0..65535 (0..65535 mV)
     * Scale: 1
     * Offset: 0
     */
    uint16_t apps_0_voltage_range_min;

    /**
     * APPS channel #0 maximum range expressed in mV
     *
     * Range: 0..65535 (0..65535 mV)
     * Scale: 1
     * Offset: 0
     */
    uint16_t apps_0_voltage_range_max;

    /**
     * APPS channel #1 minimum range expressed in mV
     *
     * Range: 0..65535 (0..65535 mV)
     * Scale: 1
     * Offset: 0
     */
    uint16_t apps_1_voltage_range_min;

    /**
     * APPS channel #1 maximum range expressed in mV
     *
     * Range: 0..65535 (0..65535 mV)
     * Scale: 1
     * Offset: 0
     */
    uint16_t apps_1_voltage_range_max;
};

/**
 * Signals in message DASH__carCommands.
 *
 * (send_type: IfActive)
 *
 * All signal values are as on the CAN bus.
 */
struct mcb_dash_car_commands_t {
    /**
     * The password to enter diagnostic mode of the BMS_LV
     *
     * Range: 0..32768 (0..32768 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t bms_lv_diag_pwd;

    /**
     * The override state to force the LV relay: no override (OFF/0), alwasy open (OPEN/1) or always closed (CLOSED/2)
     *
     * Range: 0..2 (0..2 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t lv_relay_override_state;
};

/**
 * Signals in message DIAG_TOOL__xcpTxBMS_LV.
 *
 * (send_type: CyclicIfActive)
 *
 * All signal values are as on the CAN bus.
 */
struct mcb_diag_tool_xcp_tx_bms_lv_t {
    /**
     * xcp payload data
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint64_t xcp_payload;
};

/**
 * Signals in message DIAG_TOOL__xcpTxDASH.
 *
 * (send_type: CyclicIfActive)
 *
 * All signal values are as on the CAN bus.
 */
struct mcb_diag_tool_xcp_tx_dash_t {
    /**
     * xcp payload data
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint64_t xcp_payload;
};

/**
 * Signals in message DIAG_TOOL__xcpTxSB_REAR.
 *
 * (send_type: CyclicIfActive)
 *
 * All signal values are as on the CAN bus.
 */
struct mcb_diag_tool_xcp_tx_sb_rear_t {
    /**
     * xcp payload data
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint64_t xcp_payload;
};

/**
 * Signals in message DIAG_TOOL__xcpTxSB_FRONT.
 *
 * (send_type: CyclicIfActive)
 *
 * All signal values are as on the CAN bus.
 */
struct mcb_diag_tool_xcp_tx_sb_front_t {
    /**
     * xcp payload data
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint64_t xcp_payload;
};

/**
 * Signals in message DIAG_TOOL__xcpTxSCANNER.
 *
 * (send_type: CyclicIfActive)
 *
 * All signal values are as on the CAN bus.
 */
struct mcb_diag_tool_xcp_tx_scanner_t {
    /**
     * xcp payload data
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint64_t xcp_payload;
};

/**
 * Signals in message DIAG_TOOL__xcpTxTLB_BAT.
 *
 * (send_type: CyclicIfActive)
 *
 * All signal values are as on the CAN bus.
 */
struct mcb_diag_tool_xcp_tx_tlb_bat_t {
    /**
     * xcp payload data
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint64_t xcp_payload;
};

/**
 * Signals in message DSPACE__timeAndDate.
 *
 * (cycle_time: 10) (send_type: Cyclic)
 *
 * All signal values are as on the CAN bus.
 */
struct mcb_dspace_time_and_date_t {
    /**
     * Current year expressed as an offset from 1970
     *
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t datetime_year;

    /**
     * Current month of the year (1 = January, 12 = December)
     *
     * Range: 0..11 (0..11 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t datetime_month;

    /**
     * Current day of the month, from 1 to 31
     *
     * Range: 1..31 (1..31 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t datetime_day;

    /**
     * Current hours of the day (1-24)
     *
     * Range: 0..23 (0..23 h)
     * Scale: 1
     * Offset: 0
     */
    uint8_t datetime_hours;

    /**
     * Current minutes of the hour
     *
     * Range: 0..59 (0..59 min)
     * Scale: 1
     * Offset: 0
     */
    uint8_t datetime_minutes;

    /**
     * Current seconds of the minute
     *
     * Range: 0..59 (0..59 sec)
     * Scale: 1
     * Offset: 0
     */
    uint8_t datetime_seconds;

    /**
     * Current tens of the second
     *
     * Range: 0..99 (0..99 sec)
     * Scale: 1
     * Offset: 0
     */
    uint8_t datetime_houndres_of_a_seconds;
};

/**
 * Signals in message DSPACE__peripheralsCTRL.
 *
 * (cycle_time: 10) (send_type: Cyclic)
 *
 * All signal values are as on the CAN bus.
 */
struct mcb_dspace_peripherals_ctrl_t {
    /**
     * The command to turn on the brake light (0 inactive - 1 active)
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t brake_light_active_cmd;

    /**
     * The command to close the SDC relay (0 open - 1 close)
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dash_sdc_rly_close_cmd;

    /**
     * PWM duty cycle percentage for Radiator Fans control
     *
     * Range: 0..100 (0..100 %)
     * Scale: 1
     * Offset: 0
     */
    uint8_t rad_fan_pwm_duty_cicle_ctrl;

    /**
     * Speed percentage for Cooling Pumps control
     *
     * Range: 0..100 (0..100 %)
     * Scale: 1
     * Offset: 0
     */
    uint8_t cool_pumps_speed_ctrl;
};

/**
 * Signals in message DSPACE__pwtFrontTemp.
 *
 * (cycle_time: 100) (send_type: Cyclic)
 *
 * All signal values are as on the CAN bus.
 */
struct mcb_dspace_pwt_front_temp_t {
    /**
     * The temperature of the front left inverter
     *
     * Range: -3276..3276 (-3276..3276 degC)
     * Scale: 1
     * Offset: 0
     */
    uint16_t inverter_fl_temp;

    /**
     * The temperature of the front left motor
     *
     * Range: -3276..3276 (-3276..3276 degC)
     * Scale: 1
     * Offset: 0
     */
    uint16_t motor_fl_temp;

    /**
     * The temperature of the front right inverter
     *
     * Range: -3276..3276 (-3276..3276 degC)
     * Scale: 1
     * Offset: 0
     */
    uint16_t inverter_fr_temp;

    /**
     * The temperature of the front right motor
     *
     * Range: -3276..3276 (-3276..3276 degC)
     * Scale: 1
     * Offset: 0
     */
    uint16_t motor_fr_temp;
};

/**
 * Signals in message DSPACE__pwtRearTemp.
 *
 * (cycle_time: 100) (send_type: Cyclic)
 *
 * All signal values are as on the CAN bus.
 */
struct mcb_dspace_pwt_rear_temp_t {
    /**
     * The temperature of the rear left inverter
     *
     * Range: -3276..3276 (-3276..3276 degC)
     * Scale: 1
     * Offset: 0
     */
    uint16_t inverter_rl_temp;

    /**
     * The temperature of the rear left motor
     *
     * Range: -3276..3276 (-3276..3276 degC)
     * Scale: 1
     * Offset: 0
     */
    uint16_t motor_rl_temp;

    /**
     * The temperature of the rear right inverter
     *
     * Range: -3276..3276 (-3276..3276 degC)
     * Scale: 1
     * Offset: 0
     */
    uint16_t inverter_rr_temp;

    /**
     * The temperature of the rear right motor
     *
     * Range: -3276..3276 (-3276..3276 degC)
     * Scale: 1
     * Offset: 0
     */
    uint16_t motor_rr_temp;
};

/**
 * Signals in message DSPACE__xcpTx.
 *
 * (send_type: CyclicIfActive)
 *
 * All signal values are as on the CAN bus.
 */
struct mcb_dspace_xcp_tx_t {
    /**
     * xcp payload data
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint64_t xcp_payload;
};

/**
 * Signals in message DSPACE__signals.
 *
 * (cycle_time: 100) (send_type: Cyclic)
 *
 * All signal values are as on the CAN bus.
 */
struct mcb_dspace_signals_t {
    /**
     * HV Battery State Of Charge percentage
     *
     * Range: 100..0 (100..0 %)
     * Scale: 1
     * Offset: 0
     */
    uint8_t hvbat_soc;
};

/**
 * Signals in message DSPACE__fsmStates.
 *
 * (cycle_time: 100) (send_type: Cyclic)
 *
 * All signal values are as on the CAN bus.
 */
struct mcb_dspace_fsm_states_t {
    /**
     * The state of the main/RTD FSM of dspace
     *
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dspace_main_fsm_state;

    /**
     * The state of the AMK Inverter Front Left FSM of dspace
     *
     * Range: 0..6 (0..6 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dspace_amk_inv_fl_fsm_state;

    /**
     * The state of the AMK Inverter Front Right FSM of dspace
     *
     * Range: 0..6 (0..6 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dspace_amk_inv_fr_fsm_state;

    /**
     * The state of the AMK Inverter Rear Left FSM of dspace
     *
     * Range: 0..6 (0..6 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dspace_amk_inv_rl_fsm_state;

    /**
     * The state of the AMK Inverter Rear Right FSM of dspace
     *
     * Range: 0..6 (0..6 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t dspace_amk_inv_rr_fsm_state;
};

/**
 * Signals in message DSPACE__hello.
 *
 * (send_type: IfActive)
 *
 * All signal values are as on the CAN bus.
 */
struct mcb_dspace_hello_t {
    /**
     * firmware major version number
     *
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t fw_major_version;

    /**
     * firmware minor version number
     *
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t fw_minor_version;

    /**
     * firmware patch version number
     *
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t fw_patch_version;
};

/**
 * Signals in message DSPACE__dashLedsColorRGB.
 *
 * (cycle_time: 200) (send_type: Cyclic)
 *
 * All signal values are as on the CAN bus.
 */
struct mcb_dspace_dash_leds_color_rgb_t {
    /**
     * The red channel of LED #1 of the dashboard
     *
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t led_1_red;

    /**
     * The green channel of LED #1 of the dashboard
     *
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t led_1_green;

    /**
     * The blue channel of LED #1 of the dashboard
     *
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t led_1_blue;

    /**
     * The red channel of LED #2 of the dashboard
     *
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t led_2_red;

    /**
     * The green channel of LED #2 of the dashboard
     *
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t led_2_green;

    /**
     * The blue channel of LED #2 of the dashboard
     *
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t led_2_blue;

    /**
     * The red channel of LED #3 of the dashboard
     *
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t led_3_red;

    /**
     * The green channel of LED #3 of the dashboard
     *
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t led_3_green;

    /**
     * The blue channel of LED #3 of the dashboard
     *
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t led_3_blue;

    /**
     * The red channel of LED #4 of the dashboard
     *
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t led_4_red;

    /**
     * The green channel of LED #4 of the dashboard
     *
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t led_4_green;

    /**
     * The blue channel of LED #4 of the dashboard
     *
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t led_4_blue;
};

/**
 * Signals in message SCANNER__xcpTx.
 *
 * (send_type: CyclicIfActive)
 *
 * All signal values are as on the CAN bus.
 */
struct mcb_scanner_xcp_tx_t {
    /**
     * xcp payload data
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint64_t xcp_payload;
};

/**
 * Pack message IRTS_placeholderMessage.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int mcb_irts_placeholder_message_pack(
    uint8_t *dst_p,
    const struct mcb_irts_placeholder_message_t *src_p,
    size_t size);

/**
 * Unpack message IRTS_placeholderMessage.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int mcb_irts_placeholder_message_unpack(
    struct mcb_irts_placeholder_message_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from IRTS_placeholderMessage.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int mcb_irts_placeholder_message_init(struct mcb_irts_placeholder_message_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint64_t mcb_irts_placeholder_message_irts_signal_placeholder_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_irts_placeholder_message_irts_signal_placeholder_decode(uint64_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_irts_placeholder_message_irts_signal_placeholder_is_in_range(uint64_t value);

/**
 * Pack message SB_FRONT__analogDevice.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int mcb_sb_front_analog_device_pack(
    uint8_t *dst_p,
    const struct mcb_sb_front_analog_device_t *src_p,
    size_t size);

/**
 * Unpack message SB_FRONT__analogDevice.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int mcb_sb_front_analog_device_unpack(
    struct mcb_sb_front_analog_device_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from SB_FRONT__analogDevice.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int mcb_sb_front_analog_device_init(struct mcb_sb_front_analog_device_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t mcb_sb_front_analog_device_apps_0_voltage_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_sb_front_analog_device_apps_0_voltage_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_sb_front_analog_device_apps_0_voltage_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t mcb_sb_front_analog_device_apps_1_voltage_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_sb_front_analog_device_apps_1_voltage_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_sb_front_analog_device_apps_1_voltage_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t mcb_sb_front_analog_device_steer_rme_voltage_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_sb_front_analog_device_steer_rme_voltage_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_sb_front_analog_device_steer_rme_voltage_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t mcb_sb_front_analog_device_brake_press_front_voltage_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_sb_front_analog_device_brake_press_front_voltage_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_sb_front_analog_device_brake_press_front_voltage_is_in_range(uint16_t value);

/**
 * Pack message SB_FRONT__SDCsensingStatus.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int mcb_sb_front_sd_csensing_status_pack(
    uint8_t *dst_p,
    const struct mcb_sb_front_sd_csensing_status_t *src_p,
    size_t size);

/**
 * Unpack message SB_FRONT__SDCsensingStatus.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int mcb_sb_front_sd_csensing_status_unpack(
    struct mcb_sb_front_sd_csensing_status_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from SB_FRONT__SDCsensingStatus.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int mcb_sb_front_sd_csensing_status_init(struct mcb_sb_front_sd_csensing_status_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_sb_front_sd_csensing_status_sdc_post_inertia_is_active_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_sb_front_sd_csensing_status_sdc_post_inertia_is_active_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_sb_front_sd_csensing_status_sdc_post_inertia_is_active_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_sb_front_sd_csensing_status_sdc_post_bots_is_active_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_sb_front_sd_csensing_status_sdc_post_bots_is_active_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_sb_front_sd_csensing_status_sdc_post_bots_is_active_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_sb_front_sd_csensing_status_sdc_post_cp_push_btn_is_active_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_sb_front_sd_csensing_status_sdc_post_cp_push_btn_is_active_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_sb_front_sd_csensing_status_sdc_post_cp_push_btn_is_active_is_in_range(uint8_t value);

/**
 * Pack message SB_FRONT__potentiometer.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int mcb_sb_front_potentiometer_pack(
    uint8_t *dst_p,
    const struct mcb_sb_front_potentiometer_t *src_p,
    size_t size);

/**
 * Unpack message SB_FRONT__potentiometer.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int mcb_sb_front_potentiometer_unpack(
    struct mcb_sb_front_potentiometer_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from SB_FRONT__potentiometer.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int mcb_sb_front_potentiometer_init(struct mcb_sb_front_potentiometer_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t mcb_sb_front_potentiometer_lpps_damper_fl_voltage_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_sb_front_potentiometer_lpps_damper_fl_voltage_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_sb_front_potentiometer_lpps_damper_fl_voltage_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t mcb_sb_front_potentiometer_lpps_damper_fr_voltage_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_sb_front_potentiometer_lpps_damper_fr_voltage_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_sb_front_potentiometer_lpps_damper_fr_voltage_is_in_range(uint16_t value);

/**
 * Pack message SB_FRONT__xcpTx.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int mcb_sb_front_xcp_tx_pack(
    uint8_t *dst_p,
    const struct mcb_sb_front_xcp_tx_t *src_p,
    size_t size);

/**
 * Unpack message SB_FRONT__xcpTx.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int mcb_sb_front_xcp_tx_unpack(
    struct mcb_sb_front_xcp_tx_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from SB_FRONT__xcpTx.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int mcb_sb_front_xcp_tx_init(struct mcb_sb_front_xcp_tx_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint64_t mcb_sb_front_xcp_tx_xcp_payload_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_sb_front_xcp_tx_xcp_payload_decode(uint64_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_sb_front_xcp_tx_xcp_payload_is_in_range(uint64_t value);

/**
 * Pack message SB_FRONT__hello.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int mcb_sb_front_hello_pack(
    uint8_t *dst_p,
    const struct mcb_sb_front_hello_t *src_p,
    size_t size);

/**
 * Unpack message SB_FRONT__hello.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int mcb_sb_front_hello_unpack(
    struct mcb_sb_front_hello_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from SB_FRONT__hello.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int mcb_sb_front_hello_init(struct mcb_sb_front_hello_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_sb_front_hello_fw_major_version_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_sb_front_hello_fw_major_version_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_sb_front_hello_fw_major_version_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_sb_front_hello_fw_minor_version_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_sb_front_hello_fw_minor_version_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_sb_front_hello_fw_minor_version_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_sb_front_hello_fw_patch_version_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_sb_front_hello_fw_patch_version_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_sb_front_hello_fw_patch_version_is_in_range(uint8_t value);

/**
 * Pack message SB_FRONT__ntcResistance.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int mcb_sb_front_ntc_resistance_pack(
    uint8_t *dst_p,
    const struct mcb_sb_front_ntc_resistance_t *src_p,
    size_t size);

/**
 * Unpack message SB_FRONT__ntcResistance.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int mcb_sb_front_ntc_resistance_unpack(
    struct mcb_sb_front_ntc_resistance_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from SB_FRONT__ntcResistance.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int mcb_sb_front_ntc_resistance_init(struct mcb_sb_front_ntc_resistance_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t mcb_sb_front_ntc_resistance_jacket_fl_ntc_resistance_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_sb_front_ntc_resistance_jacket_fl_ntc_resistance_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_sb_front_ntc_resistance_jacket_fl_ntc_resistance_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t mcb_sb_front_ntc_resistance_jacket_fr_ntc_resistance_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_sb_front_ntc_resistance_jacket_fr_ntc_resistance_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_sb_front_ntc_resistance_jacket_fr_ntc_resistance_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t mcb_sb_front_ntc_resistance_coldplate_l_ntc_resistance_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_sb_front_ntc_resistance_coldplate_l_ntc_resistance_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_sb_front_ntc_resistance_coldplate_l_ntc_resistance_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t mcb_sb_front_ntc_resistance_coldplate_r_ntc_resistance_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_sb_front_ntc_resistance_coldplate_r_ntc_resistance_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_sb_front_ntc_resistance_coldplate_r_ntc_resistance_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t mcb_sb_front_ntc_resistance_spare_ntc_0_resistance_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_sb_front_ntc_resistance_spare_ntc_0_resistance_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_sb_front_ntc_resistance_spare_ntc_0_resistance_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t mcb_sb_front_ntc_resistance_spare_ntc_1_resistance_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_sb_front_ntc_resistance_spare_ntc_1_resistance_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_sb_front_ntc_resistance_spare_ntc_1_resistance_is_in_range(uint16_t value);

/**
 * Pack message SB_REAR__analogDevice.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int mcb_sb_rear_analog_device_pack(
    uint8_t *dst_p,
    const struct mcb_sb_rear_analog_device_t *src_p,
    size_t size);

/**
 * Unpack message SB_REAR__analogDevice.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int mcb_sb_rear_analog_device_unpack(
    struct mcb_sb_rear_analog_device_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from SB_REAR__analogDevice.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int mcb_sb_rear_analog_device_init(struct mcb_sb_rear_analog_device_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t mcb_sb_rear_analog_device_cool_press_left_voltage_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_sb_rear_analog_device_cool_press_left_voltage_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_sb_rear_analog_device_cool_press_left_voltage_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t mcb_sb_rear_analog_device_cool_press_right_voltage_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_sb_rear_analog_device_cool_press_right_voltage_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_sb_rear_analog_device_cool_press_right_voltage_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t mcb_sb_rear_analog_device_brake_press_rear_voltage_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_sb_rear_analog_device_brake_press_rear_voltage_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_sb_rear_analog_device_brake_press_rear_voltage_is_in_range(uint16_t value);

/**
 * Pack message SB_REAR__criticalPeripherals.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int mcb_sb_rear_critical_peripherals_pack(
    uint8_t *dst_p,
    const struct mcb_sb_rear_critical_peripherals_t *src_p,
    size_t size);

/**
 * Unpack message SB_REAR__criticalPeripherals.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int mcb_sb_rear_critical_peripherals_unpack(
    struct mcb_sb_rear_critical_peripherals_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from SB_REAR__criticalPeripherals.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int mcb_sb_rear_critical_peripherals_init(struct mcb_sb_rear_critical_peripherals_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_sb_rear_critical_peripherals_discharge_is_active_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_sb_rear_critical_peripherals_discharge_is_active_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_sb_rear_critical_peripherals_discharge_is_active_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_sb_rear_critical_peripherals_bspd_has_error_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_sb_rear_critical_peripherals_bspd_has_error_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_sb_rear_critical_peripherals_bspd_has_error_is_in_range(uint8_t value);

/**
 * Pack message SB_REAR__SDCsensingStatus.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int mcb_sb_rear_sd_csensing_status_pack(
    uint8_t *dst_p,
    const struct mcb_sb_rear_sd_csensing_status_t *src_p,
    size_t size);

/**
 * Unpack message SB_REAR__SDCsensingStatus.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int mcb_sb_rear_sd_csensing_status_unpack(
    struct mcb_sb_rear_sd_csensing_status_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from SB_REAR__SDCsensingStatus.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int mcb_sb_rear_sd_csensing_status_init(struct mcb_sb_rear_sd_csensing_status_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_sb_rear_sd_csensing_status_sdc_post_bspd_is_closed_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_sb_rear_sd_csensing_status_sdc_post_bspd_is_closed_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_sb_rear_sd_csensing_status_sdc_post_bspd_is_closed_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_sb_rear_sd_csensing_status_sdc_pre_push_btns_is_closed_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_sb_rear_sd_csensing_status_sdc_pre_push_btns_is_closed_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_sb_rear_sd_csensing_status_sdc_pre_push_btns_is_closed_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_sb_rear_sd_csensing_status_sdc_post_dc_bus_is_closed_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_sb_rear_sd_csensing_status_sdc_post_dc_bus_is_closed_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_sb_rear_sd_csensing_status_sdc_post_dc_bus_is_closed_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_sb_rear_sd_csensing_status_sdc_post_inv_fr_is_closed_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_sb_rear_sd_csensing_status_sdc_post_inv_fr_is_closed_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_sb_rear_sd_csensing_status_sdc_post_inv_fr_is_closed_is_in_range(uint8_t value);

/**
 * Pack message SB_REAR__potentiometer.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int mcb_sb_rear_potentiometer_pack(
    uint8_t *dst_p,
    const struct mcb_sb_rear_potentiometer_t *src_p,
    size_t size);

/**
 * Unpack message SB_REAR__potentiometer.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int mcb_sb_rear_potentiometer_unpack(
    struct mcb_sb_rear_potentiometer_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from SB_REAR__potentiometer.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int mcb_sb_rear_potentiometer_init(struct mcb_sb_rear_potentiometer_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t mcb_sb_rear_potentiometer_lpps_damper_rl_voltage_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_sb_rear_potentiometer_lpps_damper_rl_voltage_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_sb_rear_potentiometer_lpps_damper_rl_voltage_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t mcb_sb_rear_potentiometer_lpps_damper_rr_voltage_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_sb_rear_potentiometer_lpps_damper_rr_voltage_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_sb_rear_potentiometer_lpps_damper_rr_voltage_is_in_range(uint16_t value);

/**
 * Pack message SB_REAR__xcpTx.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int mcb_sb_rear_xcp_tx_pack(
    uint8_t *dst_p,
    const struct mcb_sb_rear_xcp_tx_t *src_p,
    size_t size);

/**
 * Unpack message SB_REAR__xcpTx.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int mcb_sb_rear_xcp_tx_unpack(
    struct mcb_sb_rear_xcp_tx_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from SB_REAR__xcpTx.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int mcb_sb_rear_xcp_tx_init(struct mcb_sb_rear_xcp_tx_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint64_t mcb_sb_rear_xcp_tx_xcp_payload_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_sb_rear_xcp_tx_xcp_payload_decode(uint64_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_sb_rear_xcp_tx_xcp_payload_is_in_range(uint64_t value);

/**
 * Pack message SB_REAR__hello.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int mcb_sb_rear_hello_pack(
    uint8_t *dst_p,
    const struct mcb_sb_rear_hello_t *src_p,
    size_t size);

/**
 * Unpack message SB_REAR__hello.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int mcb_sb_rear_hello_unpack(
    struct mcb_sb_rear_hello_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from SB_REAR__hello.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int mcb_sb_rear_hello_init(struct mcb_sb_rear_hello_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_sb_rear_hello_fw_major_version_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_sb_rear_hello_fw_major_version_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_sb_rear_hello_fw_major_version_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_sb_rear_hello_fw_minor_version_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_sb_rear_hello_fw_minor_version_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_sb_rear_hello_fw_minor_version_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_sb_rear_hello_fw_patch_version_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_sb_rear_hello_fw_patch_version_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_sb_rear_hello_fw_patch_version_is_in_range(uint8_t value);

/**
 * Pack message SB_REAR__ntcResistance.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int mcb_sb_rear_ntc_resistance_pack(
    uint8_t *dst_p,
    const struct mcb_sb_rear_ntc_resistance_t *src_p,
    size_t size);

/**
 * Unpack message SB_REAR__ntcResistance.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int mcb_sb_rear_ntc_resistance_unpack(
    struct mcb_sb_rear_ntc_resistance_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from SB_REAR__ntcResistance.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int mcb_sb_rear_ntc_resistance_init(struct mcb_sb_rear_ntc_resistance_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t mcb_sb_rear_ntc_resistance_jacket_rl_ntc_resistance_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_sb_rear_ntc_resistance_jacket_rl_ntc_resistance_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_sb_rear_ntc_resistance_jacket_rl_ntc_resistance_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t mcb_sb_rear_ntc_resistance_jacket_rr_ntc_resistance_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_sb_rear_ntc_resistance_jacket_rr_ntc_resistance_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_sb_rear_ntc_resistance_jacket_rr_ntc_resistance_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t mcb_sb_rear_ntc_resistance_rad_rl_in_ntc_resistance_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_sb_rear_ntc_resistance_rad_rl_in_ntc_resistance_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_sb_rear_ntc_resistance_rad_rl_in_ntc_resistance_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t mcb_sb_rear_ntc_resistance_rad_rl_out_ntc_resistance_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_sb_rear_ntc_resistance_rad_rl_out_ntc_resistance_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_sb_rear_ntc_resistance_rad_rl_out_ntc_resistance_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t mcb_sb_rear_ntc_resistance_rad_rr_in_ntc_resistance_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_sb_rear_ntc_resistance_rad_rr_in_ntc_resistance_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_sb_rear_ntc_resistance_rad_rr_in_ntc_resistance_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t mcb_sb_rear_ntc_resistance_rad_rr_out_ntc_resistance_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_sb_rear_ntc_resistance_rad_rr_out_ntc_resistance_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_sb_rear_ntc_resistance_rad_rr_out_ntc_resistance_is_in_range(uint16_t value);

/**
 * Pack message TLB_BAT__signalsStatus.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int mcb_tlb_bat_signals_status_pack(
    uint8_t *dst_p,
    const struct mcb_tlb_bat_signals_status_t *src_p,
    size_t size);

/**
 * Unpack message TLB_BAT__signalsStatus.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int mcb_tlb_bat_signals_status_unpack(
    struct mcb_tlb_bat_signals_status_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from TLB_BAT__signalsStatus.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int mcb_tlb_bat_signals_status_init(struct mcb_tlb_bat_signals_status_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_tlb_bat_signals_status_air_pos_cmd_is_active_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_tlb_bat_signals_status_air_pos_cmd_is_active_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_tlb_bat_signals_status_air_pos_cmd_is_active_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_tlb_bat_signals_status_air_pos_is_closed_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_tlb_bat_signals_status_air_pos_is_closed_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_tlb_bat_signals_status_air_pos_is_closed_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_tlb_bat_signals_status_air_neg_cmd_is_active_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_tlb_bat_signals_status_air_neg_cmd_is_active_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_tlb_bat_signals_status_air_neg_cmd_is_active_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_tlb_bat_signals_status_air_neg_is_closed_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_tlb_bat_signals_status_air_neg_is_closed_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_tlb_bat_signals_status_air_neg_is_closed_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_tlb_bat_signals_status_dcbus_prech_rly_cmd_is_active_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_tlb_bat_signals_status_dcbus_prech_rly_cmd_is_active_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_tlb_bat_signals_status_dcbus_prech_rly_cmd_is_active_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_tlb_bat_signals_status_dcbus_prech_rly_is_closed_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_tlb_bat_signals_status_dcbus_prech_rly_is_closed_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_tlb_bat_signals_status_dcbus_prech_rly_is_closed_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_tlb_bat_signals_status_ams_err_is_active_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_tlb_bat_signals_status_ams_err_is_active_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_tlb_bat_signals_status_ams_err_is_active_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_tlb_bat_signals_status_imd_err_is_active_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_tlb_bat_signals_status_imd_err_is_active_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_tlb_bat_signals_status_imd_err_is_active_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_tlb_bat_signals_status_tsal_green_is_active_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_tlb_bat_signals_status_tsal_green_is_active_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_tlb_bat_signals_status_tsal_green_is_active_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_tlb_bat_signals_status_dcbus_is_over60_v_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_tlb_bat_signals_status_dcbus_is_over60_v_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_tlb_bat_signals_status_dcbus_is_over60_v_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_tlb_bat_signals_status_imp_any_is_active_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_tlb_bat_signals_status_imp_any_is_active_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_tlb_bat_signals_status_imp_any_is_active_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_tlb_bat_signals_status_imp_hv_relays_state_is_active_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_tlb_bat_signals_status_imp_hv_relays_state_is_active_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_tlb_bat_signals_status_imp_hv_relays_state_is_active_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_tlb_bat_signals_status_imp_dcbus_is_active_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_tlb_bat_signals_status_imp_dcbus_is_active_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_tlb_bat_signals_status_imp_dcbus_is_active_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_tlb_bat_signals_status_air_pos_stg_mech_state_signal_is_active_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_tlb_bat_signals_status_air_pos_stg_mech_state_signal_is_active_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_tlb_bat_signals_status_air_pos_stg_mech_state_signal_is_active_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_tlb_bat_signals_status_air_neg_stg_mech_state_signal_is_active_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_tlb_bat_signals_status_air_neg_stg_mech_state_signal_is_active_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_tlb_bat_signals_status_air_neg_stg_mech_state_signal_is_active_is_in_range(uint8_t value);

/**
 * Pack message TLB_BAT__SDCsensingStatus.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int mcb_tlb_bat_sd_csensing_status_pack(
    uint8_t *dst_p,
    const struct mcb_tlb_bat_sd_csensing_status_t *src_p,
    size_t size);

/**
 * Unpack message TLB_BAT__SDCsensingStatus.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int mcb_tlb_bat_sd_csensing_status_unpack(
    struct mcb_tlb_bat_sd_csensing_status_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from TLB_BAT__SDCsensingStatus.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int mcb_tlb_bat_sd_csensing_status_init(struct mcb_tlb_bat_sd_csensing_status_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_tlb_bat_sd_csensing_status_sdc_tsac_initial_in_is_active_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_tlb_bat_sd_csensing_status_sdc_tsac_initial_in_is_active_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_tlb_bat_sd_csensing_status_sdc_tsac_initial_in_is_active_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_tlb_bat_sd_csensing_status_sdc_post_ams_imd_relay_is_active_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_tlb_bat_sd_csensing_status_sdc_post_ams_imd_relay_is_active_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_tlb_bat_sd_csensing_status_sdc_post_ams_imd_relay_is_active_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_tlb_bat_sd_csensing_status_sdc_tsac_final_in_is_active_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_tlb_bat_sd_csensing_status_sdc_tsac_final_in_is_active_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_tlb_bat_sd_csensing_status_sdc_tsac_final_in_is_active_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_tlb_bat_sd_csensing_status_sdc_prech_bypass_relay_is_closed_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_tlb_bat_sd_csensing_status_sdc_prech_bypass_relay_is_closed_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_tlb_bat_sd_csensing_status_sdc_prech_bypass_relay_is_closed_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_tlb_bat_sd_csensing_status_sdc_tsac_initial_in_voltage_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_tlb_bat_sd_csensing_status_sdc_tsac_initial_in_voltage_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_tlb_bat_sd_csensing_status_sdc_tsac_initial_in_voltage_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_tlb_bat_sd_csensing_status_sdc_tsac_final_in_voltage_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_tlb_bat_sd_csensing_status_sdc_tsac_final_in_voltage_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_tlb_bat_sd_csensing_status_sdc_tsac_final_in_voltage_is_in_range(uint8_t value);

/**
 * Pack message TLB_BAT__xcpTx.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int mcb_tlb_bat_xcp_tx_pack(
    uint8_t *dst_p,
    const struct mcb_tlb_bat_xcp_tx_t *src_p,
    size_t size);

/**
 * Unpack message TLB_BAT__xcpTx.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int mcb_tlb_bat_xcp_tx_unpack(
    struct mcb_tlb_bat_xcp_tx_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from TLB_BAT__xcpTx.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int mcb_tlb_bat_xcp_tx_init(struct mcb_tlb_bat_xcp_tx_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint64_t mcb_tlb_bat_xcp_tx_xcp_payload_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_tlb_bat_xcp_tx_xcp_payload_decode(uint64_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_tlb_bat_xcp_tx_xcp_payload_is_in_range(uint64_t value);

/**
 * Pack message TLB_BAT__hello.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int mcb_tlb_bat_hello_pack(
    uint8_t *dst_p,
    const struct mcb_tlb_bat_hello_t *src_p,
    size_t size);

/**
 * Unpack message TLB_BAT__hello.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int mcb_tlb_bat_hello_unpack(
    struct mcb_tlb_bat_hello_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from TLB_BAT__hello.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int mcb_tlb_bat_hello_init(struct mcb_tlb_bat_hello_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_tlb_bat_hello_fw_major_version_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_tlb_bat_hello_fw_major_version_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_tlb_bat_hello_fw_major_version_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_tlb_bat_hello_fw_minor_version_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_tlb_bat_hello_fw_minor_version_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_tlb_bat_hello_fw_minor_version_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_tlb_bat_hello_fw_patch_version_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_tlb_bat_hello_fw_patch_version_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_tlb_bat_hello_fw_patch_version_is_in_range(uint8_t value);

/**
 * Pack message IMU__Accelerometers.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int mcb_imu_accelerometers_pack(
    uint8_t *dst_p,
    const struct mcb_imu_accelerometers_t *src_p,
    size_t size);

/**
 * Unpack message IMU__Accelerometers.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int mcb_imu_accelerometers_unpack(
    struct mcb_imu_accelerometers_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from IMU__Accelerometers.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int mcb_imu_accelerometers_init(struct mcb_imu_accelerometers_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t mcb_imu_accelerometers_accel_x_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_imu_accelerometers_accel_x_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_imu_accelerometers_accel_x_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t mcb_imu_accelerometers_accel_y_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_imu_accelerometers_accel_y_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_imu_accelerometers_accel_y_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t mcb_imu_accelerometers_accel_z_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_imu_accelerometers_accel_z_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_imu_accelerometers_accel_z_is_in_range(int16_t value);

/**
 * Pack message IMU__Gyro.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int mcb_imu_gyro_pack(
    uint8_t *dst_p,
    const struct mcb_imu_gyro_t *src_p,
    size_t size);

/**
 * Unpack message IMU__Gyro.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int mcb_imu_gyro_unpack(
    struct mcb_imu_gyro_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from IMU__Gyro.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int mcb_imu_gyro_init(struct mcb_imu_gyro_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t mcb_imu_gyro_gyro_x_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_imu_gyro_gyro_x_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_imu_gyro_gyro_x_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t mcb_imu_gyro_gyro_y_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_imu_gyro_gyro_y_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_imu_gyro_gyro_y_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t mcb_imu_gyro_gyro_z_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_imu_gyro_gyro_z_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_imu_gyro_gyro_z_is_in_range(int16_t value);

/**
 * Pack message IMU__Euler.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int mcb_imu_euler_pack(
    uint8_t *dst_p,
    const struct mcb_imu_euler_t *src_p,
    size_t size);

/**
 * Unpack message IMU__Euler.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int mcb_imu_euler_unpack(
    struct mcb_imu_euler_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from IMU__Euler.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int mcb_imu_euler_init(struct mcb_imu_euler_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t mcb_imu_euler_roll_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_imu_euler_roll_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_imu_euler_roll_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t mcb_imu_euler_pitch_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_imu_euler_pitch_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_imu_euler_pitch_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t mcb_imu_euler_yaw_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_imu_euler_yaw_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_imu_euler_yaw_is_in_range(int16_t value);

/**
 * Pack message IMU__GPS1_Position.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int mcb_imu_gps1_position_pack(
    uint8_t *dst_p,
    const struct mcb_imu_gps1_position_t *src_p,
    size_t size);

/**
 * Unpack message IMU__GPS1_Position.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int mcb_imu_gps1_position_unpack(
    struct mcb_imu_gps1_position_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from IMU__GPS1_Position.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int mcb_imu_gps1_position_init(struct mcb_imu_gps1_position_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t mcb_imu_gps1_position_latitude_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_imu_gps1_position_latitude_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_imu_gps1_position_latitude_is_in_range(int32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t mcb_imu_gps1_position_longitude_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_imu_gps1_position_longitude_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_imu_gps1_position_longitude_is_in_range(int32_t value);

/**
 * Pack message IMU__VelocityBody.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int mcb_imu_velocity_body_pack(
    uint8_t *dst_p,
    const struct mcb_imu_velocity_body_t *src_p,
    size_t size);

/**
 * Unpack message IMU__VelocityBody.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int mcb_imu_velocity_body_unpack(
    struct mcb_imu_velocity_body_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from IMU__VelocityBody.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int mcb_imu_velocity_body_init(struct mcb_imu_velocity_body_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t mcb_imu_velocity_body_velocity_x_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_imu_velocity_body_velocity_x_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_imu_velocity_body_velocity_x_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t mcb_imu_velocity_body_velocity_y_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_imu_velocity_body_velocity_y_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_imu_velocity_body_velocity_y_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t mcb_imu_velocity_body_velocity_z_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_imu_velocity_body_velocity_z_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_imu_velocity_body_velocity_z_is_in_range(int16_t value);

/**
 * Pack message IMU__TrackSlipCurv.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int mcb_imu_track_slip_curv_pack(
    uint8_t *dst_p,
    const struct mcb_imu_track_slip_curv_t *src_p,
    size_t size);

/**
 * Unpack message IMU__TrackSlipCurv.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int mcb_imu_track_slip_curv_unpack(
    struct mcb_imu_track_slip_curv_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from IMU__TrackSlipCurv.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int mcb_imu_track_slip_curv_init(struct mcb_imu_track_slip_curv_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t mcb_imu_track_slip_curv_angle_track_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_imu_track_slip_curv_angle_track_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_imu_track_slip_curv_angle_track_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t mcb_imu_track_slip_curv_angle_slip_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_imu_track_slip_curv_angle_slip_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_imu_track_slip_curv_angle_slip_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t mcb_imu_track_slip_curv_curvature_radius_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_imu_track_slip_curv_curvature_radius_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_imu_track_slip_curv_curvature_radius_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_imu_track_slip_curv_auto_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_imu_track_slip_curv_auto_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_imu_track_slip_curv_auto_status_is_in_range(uint8_t value);

/**
 * Pack message TPMS__frontWheelsPressure.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int mcb_tpms_front_wheels_pressure_pack(
    uint8_t *dst_p,
    const struct mcb_tpms_front_wheels_pressure_t *src_p,
    size_t size);

/**
 * Unpack message TPMS__frontWheelsPressure.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int mcb_tpms_front_wheels_pressure_unpack(
    struct mcb_tpms_front_wheels_pressure_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from TPMS__frontWheelsPressure.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int mcb_tpms_front_wheels_pressure_init(struct mcb_tpms_front_wheels_pressure_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_tpms_front_wheels_pressure_tire_fl_sens_id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_tpms_front_wheels_pressure_tire_fl_sens_id_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_tpms_front_wheels_pressure_tire_fl_sens_id_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_tpms_front_wheels_pressure_tire_fl_status_is_spinning_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_tpms_front_wheels_pressure_tire_fl_status_is_spinning_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_tpms_front_wheels_pressure_tire_fl_status_is_spinning_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_tpms_front_wheels_pressure_tire_fl_status_is_vbatt_not_ok_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_tpms_front_wheels_pressure_tire_fl_status_is_vbatt_not_ok_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_tpms_front_wheels_pressure_tire_fl_status_is_vbatt_not_ok_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_tpms_front_wheels_pressure_tire_fl_temperature_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_tpms_front_wheels_pressure_tire_fl_temperature_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_tpms_front_wheels_pressure_tire_fl_temperature_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_tpms_front_wheels_pressure_tire_fl_pressure_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_tpms_front_wheels_pressure_tire_fl_pressure_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_tpms_front_wheels_pressure_tire_fl_pressure_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_tpms_front_wheels_pressure_tire_fr_sens_id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_tpms_front_wheels_pressure_tire_fr_sens_id_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_tpms_front_wheels_pressure_tire_fr_sens_id_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_tpms_front_wheels_pressure_tire_fr_status_is_spinning_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_tpms_front_wheels_pressure_tire_fr_status_is_spinning_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_tpms_front_wheels_pressure_tire_fr_status_is_spinning_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_tpms_front_wheels_pressure_tire_fr_status_is_vbatt_not_ok_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_tpms_front_wheels_pressure_tire_fr_status_is_vbatt_not_ok_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_tpms_front_wheels_pressure_tire_fr_status_is_vbatt_not_ok_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_tpms_front_wheels_pressure_tire_fr_temperature_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_tpms_front_wheels_pressure_tire_fr_temperature_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_tpms_front_wheels_pressure_tire_fr_temperature_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_tpms_front_wheels_pressure_tire_fr_pressure_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_tpms_front_wheels_pressure_tire_fr_pressure_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_tpms_front_wheels_pressure_tire_fr_pressure_is_in_range(uint8_t value);

/**
 * Pack message TPMS__rearWheelsPressure.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int mcb_tpms_rear_wheels_pressure_pack(
    uint8_t *dst_p,
    const struct mcb_tpms_rear_wheels_pressure_t *src_p,
    size_t size);

/**
 * Unpack message TPMS__rearWheelsPressure.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int mcb_tpms_rear_wheels_pressure_unpack(
    struct mcb_tpms_rear_wheels_pressure_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from TPMS__rearWheelsPressure.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int mcb_tpms_rear_wheels_pressure_init(struct mcb_tpms_rear_wheels_pressure_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_tpms_rear_wheels_pressure_tire_rl_sens_id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_tpms_rear_wheels_pressure_tire_rl_sens_id_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_tpms_rear_wheels_pressure_tire_rl_sens_id_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_tpms_rear_wheels_pressure_tire_rl_status_is_spinning_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_tpms_rear_wheels_pressure_tire_rl_status_is_spinning_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_tpms_rear_wheels_pressure_tire_rl_status_is_spinning_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_tpms_rear_wheels_pressure_tire_rl_status_is_vbatt_not_ok_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_tpms_rear_wheels_pressure_tire_rl_status_is_vbatt_not_ok_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_tpms_rear_wheels_pressure_tire_rl_status_is_vbatt_not_ok_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_tpms_rear_wheels_pressure_tire_rl_temperature_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_tpms_rear_wheels_pressure_tire_rl_temperature_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_tpms_rear_wheels_pressure_tire_rl_temperature_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_tpms_rear_wheels_pressure_tire_rl_pressure_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_tpms_rear_wheels_pressure_tire_rl_pressure_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_tpms_rear_wheels_pressure_tire_rl_pressure_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_tpms_rear_wheels_pressure_tire_rr_sens_id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_tpms_rear_wheels_pressure_tire_rr_sens_id_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_tpms_rear_wheels_pressure_tire_rr_sens_id_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_tpms_rear_wheels_pressure_tire_rr_status_is_spinning_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_tpms_rear_wheels_pressure_tire_rr_status_is_spinning_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_tpms_rear_wheels_pressure_tire_rr_status_is_spinning_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_tpms_rear_wheels_pressure_tire_rr_status_is_vbatt_not_ok_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_tpms_rear_wheels_pressure_tire_rr_status_is_vbatt_not_ok_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_tpms_rear_wheels_pressure_tire_rr_status_is_vbatt_not_ok_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_tpms_rear_wheels_pressure_tire_rr_temperature_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_tpms_rear_wheels_pressure_tire_rr_temperature_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_tpms_rear_wheels_pressure_tire_rr_temperature_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_tpms_rear_wheels_pressure_tire_rr_pressure_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_tpms_rear_wheels_pressure_tire_rr_pressure_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_tpms_rear_wheels_pressure_tire_rr_pressure_is_in_range(uint8_t value);

/**
 * Pack message NLG5_ST.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int mcb_nlg5_st_pack(
    uint8_t *dst_p,
    const struct mcb_nlg5_st_t *src_p,
    size_t size);

/**
 * Unpack message NLG5_ST.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int mcb_nlg5_st_unpack(
    struct mcb_nlg5_st_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from NLG5_ST.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int mcb_nlg5_st_init(struct mcb_nlg5_st_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_nlg5_st_nlg5_s_he_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_nlg5_st_nlg5_s_he_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_nlg5_st_nlg5_s_he_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_nlg5_st_nlg5_s_err_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_nlg5_st_nlg5_s_err_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_nlg5_st_nlg5_s_err_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_nlg5_st_nlg5_s_war_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_nlg5_st_nlg5_s_war_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_nlg5_st_nlg5_s_war_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_nlg5_st_nlg5_s_fan_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_nlg5_st_nlg5_s_fan_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_nlg5_st_nlg5_s_fan_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_nlg5_st_nlg5_s_eum_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_nlg5_st_nlg5_s_eum_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_nlg5_st_nlg5_s_eum_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_nlg5_st_nlg5_s_um_i_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_nlg5_st_nlg5_s_um_i_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_nlg5_st_nlg5_s_um_i_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_nlg5_st_nlg5_s_um_ii_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_nlg5_st_nlg5_s_um_ii_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_nlg5_st_nlg5_s_um_ii_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_nlg5_st_nlg5_s_cp_dt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_nlg5_st_nlg5_s_cp_dt_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_nlg5_st_nlg5_s_cp_dt_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_nlg5_st_nlg5_s_bpd_i_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_nlg5_st_nlg5_s_bpd_i_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_nlg5_st_nlg5_s_bpd_i_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_nlg5_st_nlg5_s_bpd_ii_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_nlg5_st_nlg5_s_bpd_ii_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_nlg5_st_nlg5_s_bpd_ii_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_nlg5_st_nlg5_s_l_ov_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_nlg5_st_nlg5_s_l_ov_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_nlg5_st_nlg5_s_l_ov_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_nlg5_st_nlg5_s_l_oc_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_nlg5_st_nlg5_s_l_oc_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_nlg5_st_nlg5_s_l_oc_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_nlg5_st_nlg5_s_l_mc_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_nlg5_st_nlg5_s_l_mc_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_nlg5_st_nlg5_s_l_mc_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_nlg5_st_nlg5_s_l_pi_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_nlg5_st_nlg5_s_l_pi_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_nlg5_st_nlg5_s_l_pi_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_nlg5_st_nlg5_s_l_cp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_nlg5_st_nlg5_s_l_cp_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_nlg5_st_nlg5_s_l_cp_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_nlg5_st_nlg5_s_l_pmax_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_nlg5_st_nlg5_s_l_pmax_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_nlg5_st_nlg5_s_l_pmax_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_nlg5_st_nlg5_s_l_mc_max_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_nlg5_st_nlg5_s_l_mc_max_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_nlg5_st_nlg5_s_l_mc_max_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_nlg5_st_nlg5_s_l_oc_max_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_nlg5_st_nlg5_s_l_oc_max_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_nlg5_st_nlg5_s_l_oc_max_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_nlg5_st_nlg5_s_l_mo_max_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_nlg5_st_nlg5_s_l_mo_max_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_nlg5_st_nlg5_s_l_mo_max_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_nlg5_st_nlg5_s_l_t_cprim_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_nlg5_st_nlg5_s_l_t_cprim_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_nlg5_st_nlg5_s_l_t_cprim_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_nlg5_st_nlg5_s_l_t_pow_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_nlg5_st_nlg5_s_l_t_pow_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_nlg5_st_nlg5_s_l_t_pow_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_nlg5_st_nlg5_s_l_t_dio_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_nlg5_st_nlg5_s_l_t_dio_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_nlg5_st_nlg5_s_l_t_dio_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_nlg5_st_nlg5_s_l_t_tr_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_nlg5_st_nlg5_s_l_t_tr_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_nlg5_st_nlg5_s_l_t_tr_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_nlg5_st_nlg5_s_l_t_batt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_nlg5_st_nlg5_s_l_t_batt_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_nlg5_st_nlg5_s_l_t_batt_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_nlg5_st_nlg5_s_aac_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_nlg5_st_nlg5_s_aac_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_nlg5_st_nlg5_s_aac_is_in_range(uint8_t value);

/**
 * Pack message NLG5_ACT_I.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int mcb_nlg5_act_i_pack(
    uint8_t *dst_p,
    const struct mcb_nlg5_act_i_t *src_p,
    size_t size);

/**
 * Unpack message NLG5_ACT_I.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int mcb_nlg5_act_i_unpack(
    struct mcb_nlg5_act_i_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from NLG5_ACT_I.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int mcb_nlg5_act_i_init(struct mcb_nlg5_act_i_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t mcb_nlg5_act_i_nlg5_mc_act_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_nlg5_act_i_nlg5_mc_act_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_nlg5_act_i_nlg5_mc_act_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t mcb_nlg5_act_i_nlg5_mv_act_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_nlg5_act_i_nlg5_mv_act_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_nlg5_act_i_nlg5_mv_act_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t mcb_nlg5_act_i_nlg5_ov_act_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_nlg5_act_i_nlg5_ov_act_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_nlg5_act_i_nlg5_ov_act_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t mcb_nlg5_act_i_nlg5_oc_act_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_nlg5_act_i_nlg5_oc_act_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_nlg5_act_i_nlg5_oc_act_is_in_range(int16_t value);

/**
 * Pack message NLG5_ACT_II.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int mcb_nlg5_act_ii_pack(
    uint8_t *dst_p,
    const struct mcb_nlg5_act_ii_t *src_p,
    size_t size);

/**
 * Unpack message NLG5_ACT_II.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int mcb_nlg5_act_ii_unpack(
    struct mcb_nlg5_act_ii_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from NLG5_ACT_II.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int mcb_nlg5_act_ii_init(struct mcb_nlg5_act_ii_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t mcb_nlg5_act_ii_nlg5_s_mc_m_cp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_nlg5_act_ii_nlg5_s_mc_m_cp_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_nlg5_act_ii_nlg5_s_mc_m_cp_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_nlg5_act_ii_nlg5_s_mc_m_pi_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_nlg5_act_ii_nlg5_s_mc_m_pi_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_nlg5_act_ii_nlg5_s_mc_m_pi_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_nlg5_act_ii_nlg5_abv_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_nlg5_act_ii_nlg5_abv_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_nlg5_act_ii_nlg5_abv_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t mcb_nlg5_act_ii_nlg5_ahc_ext_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_nlg5_act_ii_nlg5_ahc_ext_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_nlg5_act_ii_nlg5_ahc_ext_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t mcb_nlg5_act_ii_nlg5_oc_bo_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_nlg5_act_ii_nlg5_oc_bo_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_nlg5_act_ii_nlg5_oc_bo_is_in_range(uint16_t value);

/**
 * Pack message NLG5_TEMP.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int mcb_nlg5_temp_pack(
    uint8_t *dst_p,
    const struct mcb_nlg5_temp_t *src_p,
    size_t size);

/**
 * Unpack message NLG5_TEMP.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int mcb_nlg5_temp_unpack(
    struct mcb_nlg5_temp_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from NLG5_TEMP.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int mcb_nlg5_temp_init(struct mcb_nlg5_temp_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t mcb_nlg5_temp_nlg5_p_tmp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_nlg5_temp_nlg5_p_tmp_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_nlg5_temp_nlg5_p_tmp_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t mcb_nlg5_temp_nlg5_tmp_ext1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_nlg5_temp_nlg5_tmp_ext1_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_nlg5_temp_nlg5_tmp_ext1_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t mcb_nlg5_temp_nlg5_temp_ext2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_nlg5_temp_nlg5_temp_ext2_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_nlg5_temp_nlg5_temp_ext2_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t mcb_nlg5_temp_nlg5_tmp_ext3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_nlg5_temp_nlg5_tmp_ext3_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_nlg5_temp_nlg5_tmp_ext3_is_in_range(int16_t value);

/**
 * Pack message NLG5_ERR.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int mcb_nlg5_err_pack(
    uint8_t *dst_p,
    const struct mcb_nlg5_err_t *src_p,
    size_t size);

/**
 * Unpack message NLG5_ERR.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int mcb_nlg5_err_unpack(
    struct mcb_nlg5_err_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from NLG5_ERR.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int mcb_nlg5_err_init(struct mcb_nlg5_err_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_nlg5_err_nlg5_e_oov_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_nlg5_err_nlg5_e_oov_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_nlg5_err_nlg5_e_oov_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_nlg5_err_nlg5_e_mov_ii_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_nlg5_err_nlg5_e_mov_ii_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_nlg5_err_nlg5_e_mov_ii_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_nlg5_err_nlg5_e_mov_i_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_nlg5_err_nlg5_e_mov_i_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_nlg5_err_nlg5_e_mov_i_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_nlg5_err_nlg5_e_sc_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_nlg5_err_nlg5_e_sc_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_nlg5_err_nlg5_e_sc_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_nlg5_err_nlg5_e_p_om_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_nlg5_err_nlg5_e_p_om_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_nlg5_err_nlg5_e_p_om_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_nlg5_err_nlg5_e_p_mv_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_nlg5_err_nlg5_e_p_mv_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_nlg5_err_nlg5_e_p_mv_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_nlg5_err_nlg5_e_of_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_nlg5_err_nlg5_e_of_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_nlg5_err_nlg5_e_of_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_nlg5_err_nlg5_e_mf_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_nlg5_err_nlg5_e_mf_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_nlg5_err_nlg5_e_mf_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_nlg5_err_nlg5_e_b_p_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_nlg5_err_nlg5_e_b_p_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_nlg5_err_nlg5_e_b_p_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_nlg5_err_nlg5_e_t_c_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_nlg5_err_nlg5_e_t_c_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_nlg5_err_nlg5_e_t_c_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_nlg5_err_nlg5_e_t_pow_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_nlg5_err_nlg5_e_t_pow_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_nlg5_err_nlg5_e_t_pow_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_nlg5_err_nlg5_e_t_dio_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_nlg5_err_nlg5_e_t_dio_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_nlg5_err_nlg5_e_t_dio_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_nlg5_err_nlg5_e_t_tr_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_nlg5_err_nlg5_e_t_tr_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_nlg5_err_nlg5_e_t_tr_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_nlg5_err_nlg5_e_t_ext1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_nlg5_err_nlg5_e_t_ext1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_nlg5_err_nlg5_e_t_ext1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_nlg5_err_nlg5_e_t_ext2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_nlg5_err_nlg5_e_t_ext2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_nlg5_err_nlg5_e_t_ext2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_nlg5_err_nlg5_e_t_ext3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_nlg5_err_nlg5_e_t_ext3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_nlg5_err_nlg5_e_t_ext3_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_nlg5_err_nlg5_e_f_crc_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_nlg5_err_nlg5_e_f_crc_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_nlg5_err_nlg5_e_f_crc_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_nlg5_err_nlg5_e_nv_crc_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_nlg5_err_nlg5_e_nv_crc_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_nlg5_err_nlg5_e_nv_crc_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_nlg5_err_nlg5_e_es_crc_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_nlg5_err_nlg5_e_es_crc_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_nlg5_err_nlg5_e_es_crc_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_nlg5_err_nlg5_e_ep_crc_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_nlg5_err_nlg5_e_ep_crc_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_nlg5_err_nlg5_e_ep_crc_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_nlg5_err_nlg5_e_wdt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_nlg5_err_nlg5_e_wdt_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_nlg5_err_nlg5_e_wdt_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_nlg5_err_nlg5_e_init_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_nlg5_err_nlg5_e_init_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_nlg5_err_nlg5_e_init_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_nlg5_err_nlg5_e_c_to_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_nlg5_err_nlg5_e_c_to_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_nlg5_err_nlg5_e_c_to_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_nlg5_err_nlg5_e_c_off_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_nlg5_err_nlg5_e_c_off_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_nlg5_err_nlg5_e_c_off_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_nlg5_err_nlg5_e_c_tx_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_nlg5_err_nlg5_e_c_tx_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_nlg5_err_nlg5_e_c_tx_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_nlg5_err_nlg5_e_c_rx_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_nlg5_err_nlg5_e_c_rx_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_nlg5_err_nlg5_e_c_rx_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_nlg5_err_nlg5_e_sdt_bt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_nlg5_err_nlg5_e_sdt_bt_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_nlg5_err_nlg5_e_sdt_bt_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_nlg5_err_nlg5_e_sdt_bv_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_nlg5_err_nlg5_e_sdt_bv_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_nlg5_err_nlg5_e_sdt_bv_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_nlg5_err_nlg5_e_sdt_ah_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_nlg5_err_nlg5_e_sdt_ah_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_nlg5_err_nlg5_e_sdt_ah_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_nlg5_err_nlg5_e_sdt_ct_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_nlg5_err_nlg5_e_sdt_ct_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_nlg5_err_nlg5_e_sdt_ct_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_nlg5_err_nlg5_w_pl_mv_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_nlg5_err_nlg5_w_pl_mv_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_nlg5_err_nlg5_w_pl_mv_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_nlg5_err_nlg5_w_pl_bv_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_nlg5_err_nlg5_w_pl_bv_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_nlg5_err_nlg5_w_pl_bv_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_nlg5_err_nlg5_w_pl_it_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_nlg5_err_nlg5_w_pl_it_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_nlg5_err_nlg5_w_pl_it_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_nlg5_err_nlg5_w_c_vor_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_nlg5_err_nlg5_w_c_vor_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_nlg5_err_nlg5_w_c_vor_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_nlg5_err_nlg5_w_cm_na_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_nlg5_err_nlg5_w_cm_na_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_nlg5_err_nlg5_w_cm_na_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_nlg5_err_nlg5_w_od_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_nlg5_err_nlg5_w_od_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_nlg5_err_nlg5_w_od_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_nlg5_err_nlg5_w_sc_m_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_nlg5_err_nlg5_w_sc_m_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_nlg5_err_nlg5_w_sc_m_is_in_range(uint8_t value);

/**
 * Pack message NLG5_CTL.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int mcb_nlg5_ctl_pack(
    uint8_t *dst_p,
    const struct mcb_nlg5_ctl_t *src_p,
    size_t size);

/**
 * Unpack message NLG5_CTL.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int mcb_nlg5_ctl_unpack(
    struct mcb_nlg5_ctl_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from NLG5_CTL.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int mcb_nlg5_ctl_init(struct mcb_nlg5_ctl_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_nlg5_ctl_nlg5_c_c_en_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_nlg5_ctl_nlg5_c_c_en_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_nlg5_ctl_nlg5_c_c_en_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_nlg5_ctl_nlg5_c_c_el_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_nlg5_ctl_nlg5_c_c_el_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_nlg5_ctl_nlg5_c_c_el_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_nlg5_ctl_nlg5_c_cp_v_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_nlg5_ctl_nlg5_c_cp_v_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_nlg5_ctl_nlg5_c_cp_v_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_nlg5_ctl_nlg5_c_mr_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_nlg5_ctl_nlg5_c_mr_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_nlg5_ctl_nlg5_c_mr_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t mcb_nlg5_ctl_nlg5_mc_max_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_nlg5_ctl_nlg5_mc_max_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_nlg5_ctl_nlg5_mc_max_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t mcb_nlg5_ctl_nlg5_ov_com_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_nlg5_ctl_nlg5_ov_com_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_nlg5_ctl_nlg5_ov_com_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t mcb_nlg5_ctl_nlg5_oc_com_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_nlg5_ctl_nlg5_oc_com_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_nlg5_ctl_nlg5_oc_com_is_in_range(uint16_t value);

/**
 * Pack message NLG5_DIAG_RX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int mcb_nlg5_diag_rx_pack(
    uint8_t *dst_p,
    const struct mcb_nlg5_diag_rx_t *src_p,
    size_t size);

/**
 * Unpack message NLG5_DIAG_RX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int mcb_nlg5_diag_rx_unpack(
    struct mcb_nlg5_diag_rx_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from NLG5_DIAG_RX.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int mcb_nlg5_diag_rx_init(struct mcb_nlg5_diag_rx_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint64_t mcb_nlg5_diag_rx_lad_d_param_rq_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_nlg5_diag_rx_lad_d_param_rq_decode(uint64_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_nlg5_diag_rx_lad_d_param_rq_is_in_range(uint64_t value);

/**
 * Pack message NLG5_DIAG_TX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int mcb_nlg5_diag_tx_pack(
    uint8_t *dst_p,
    const struct mcb_nlg5_diag_tx_t *src_p,
    size_t size);

/**
 * Unpack message NLG5_DIAG_TX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int mcb_nlg5_diag_tx_unpack(
    struct mcb_nlg5_diag_tx_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from NLG5_DIAG_TX.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int mcb_nlg5_diag_tx_init(struct mcb_nlg5_diag_tx_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint64_t mcb_nlg5_diag_tx_lad_d_param_rp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_nlg5_diag_tx_lad_d_param_rp_decode(uint64_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_nlg5_diag_tx_lad_d_param_rp_is_in_range(uint64_t value);

/**
 * Pack message BMS_LV__lvBatGeneral.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int mcb_bms_lv_lv_bat_general_pack(
    uint8_t *dst_p,
    const struct mcb_bms_lv_lv_bat_general_t *src_p,
    size_t size);

/**
 * Unpack message BMS_LV__lvBatGeneral.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int mcb_bms_lv_lv_bat_general_unpack(
    struct mcb_bms_lv_lv_bat_general_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from BMS_LV__lvBatGeneral.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int mcb_bms_lv_lv_bat_general_init(struct mcb_bms_lv_lv_bat_general_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t mcb_bms_lv_lv_bat_general_lv_bat_current_sens_voltage_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_bms_lv_lv_bat_general_lv_bat_current_sens_voltage_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_bms_lv_lv_bat_general_lv_bat_current_sens_voltage_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t mcb_bms_lv_lv_bat_general_lv_bat_voltage_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_bms_lv_lv_bat_general_lv_bat_voltage_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_bms_lv_lv_bat_general_lv_bat_voltage_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t mcb_bms_lv_lv_bat_general_lv_bat_summed_voltage_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_bms_lv_lv_bat_general_lv_bat_summed_voltage_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_bms_lv_lv_bat_general_lv_bat_summed_voltage_is_in_range(uint16_t value);

/**
 * Pack message BMS_LV__xcpTx.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int mcb_bms_lv_xcp_tx_pack(
    uint8_t *dst_p,
    const struct mcb_bms_lv_xcp_tx_t *src_p,
    size_t size);

/**
 * Unpack message BMS_LV__xcpTx.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int mcb_bms_lv_xcp_tx_unpack(
    struct mcb_bms_lv_xcp_tx_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from BMS_LV__xcpTx.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int mcb_bms_lv_xcp_tx_init(struct mcb_bms_lv_xcp_tx_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint64_t mcb_bms_lv_xcp_tx_xcp_payload_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_bms_lv_xcp_tx_xcp_payload_decode(uint64_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_bms_lv_xcp_tx_xcp_payload_is_in_range(uint64_t value);

/**
 * Pack message BMS_LV__cellsStatus.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int mcb_bms_lv_cells_status_pack(
    uint8_t *dst_p,
    const struct mcb_bms_lv_cells_status_t *src_p,
    size_t size);

/**
 * Unpack message BMS_LV__cellsStatus.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int mcb_bms_lv_cells_status_unpack(
    struct mcb_bms_lv_cells_status_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from BMS_LV__cellsStatus.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int mcb_bms_lv_cells_status_init(struct mcb_bms_lv_cells_status_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_bms_lv_cells_status_lv_cell_0_is_ov_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_bms_lv_cells_status_lv_cell_0_is_ov_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_bms_lv_cells_status_lv_cell_0_is_ov_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_bms_lv_cells_status_lv_cell_0_is_uv_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_bms_lv_cells_status_lv_cell_0_is_uv_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_bms_lv_cells_status_lv_cell_0_is_uv_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_bms_lv_cells_status_lv_cell_1_is_ov_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_bms_lv_cells_status_lv_cell_1_is_ov_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_bms_lv_cells_status_lv_cell_1_is_ov_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_bms_lv_cells_status_lv_cell_1_is_uv_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_bms_lv_cells_status_lv_cell_1_is_uv_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_bms_lv_cells_status_lv_cell_1_is_uv_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_bms_lv_cells_status_lv_cell_2_is_ov_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_bms_lv_cells_status_lv_cell_2_is_ov_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_bms_lv_cells_status_lv_cell_2_is_ov_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_bms_lv_cells_status_lv_cell_2_is_uv_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_bms_lv_cells_status_lv_cell_2_is_uv_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_bms_lv_cells_status_lv_cell_2_is_uv_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_bms_lv_cells_status_lv_cell_3_is_ov_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_bms_lv_cells_status_lv_cell_3_is_ov_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_bms_lv_cells_status_lv_cell_3_is_ov_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_bms_lv_cells_status_lv_cell_3_is_uv_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_bms_lv_cells_status_lv_cell_3_is_uv_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_bms_lv_cells_status_lv_cell_3_is_uv_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_bms_lv_cells_status_lv_cell_4_is_ov_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_bms_lv_cells_status_lv_cell_4_is_ov_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_bms_lv_cells_status_lv_cell_4_is_ov_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_bms_lv_cells_status_lv_cell_4_is_uv_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_bms_lv_cells_status_lv_cell_4_is_uv_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_bms_lv_cells_status_lv_cell_4_is_uv_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_bms_lv_cells_status_lv_cell_5_is_ov_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_bms_lv_cells_status_lv_cell_5_is_ov_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_bms_lv_cells_status_lv_cell_5_is_ov_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_bms_lv_cells_status_lv_cell_5_is_uv_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_bms_lv_cells_status_lv_cell_5_is_uv_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_bms_lv_cells_status_lv_cell_5_is_uv_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_bms_lv_cells_status_lv_cell_6_is_ov_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_bms_lv_cells_status_lv_cell_6_is_ov_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_bms_lv_cells_status_lv_cell_6_is_ov_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_bms_lv_cells_status_lv_cell_6_is_uv_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_bms_lv_cells_status_lv_cell_6_is_uv_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_bms_lv_cells_status_lv_cell_6_is_uv_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_bms_lv_cells_status_lv_cell_ntc_00_is_ot_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_bms_lv_cells_status_lv_cell_ntc_00_is_ot_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_bms_lv_cells_status_lv_cell_ntc_00_is_ot_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_bms_lv_cells_status_lv_cell_ntc_01_is_ot_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_bms_lv_cells_status_lv_cell_ntc_01_is_ot_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_bms_lv_cells_status_lv_cell_ntc_01_is_ot_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_bms_lv_cells_status_lv_cell_ntc_02_is_ot_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_bms_lv_cells_status_lv_cell_ntc_02_is_ot_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_bms_lv_cells_status_lv_cell_ntc_02_is_ot_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_bms_lv_cells_status_lv_cell_ntc_03_is_ot_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_bms_lv_cells_status_lv_cell_ntc_03_is_ot_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_bms_lv_cells_status_lv_cell_ntc_03_is_ot_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_bms_lv_cells_status_lv_cell_ntc_04_is_ot_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_bms_lv_cells_status_lv_cell_ntc_04_is_ot_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_bms_lv_cells_status_lv_cell_ntc_04_is_ot_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_bms_lv_cells_status_lv_cell_ntc_05_is_ot_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_bms_lv_cells_status_lv_cell_ntc_05_is_ot_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_bms_lv_cells_status_lv_cell_ntc_05_is_ot_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_bms_lv_cells_status_lv_cell_ntc_06_is_ot_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_bms_lv_cells_status_lv_cell_ntc_06_is_ot_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_bms_lv_cells_status_lv_cell_ntc_06_is_ot_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_bms_lv_cells_status_lv_cell_ntc_07_is_ot_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_bms_lv_cells_status_lv_cell_ntc_07_is_ot_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_bms_lv_cells_status_lv_cell_ntc_07_is_ot_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_bms_lv_cells_status_lv_cell_ntc_08_is_ot_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_bms_lv_cells_status_lv_cell_ntc_08_is_ot_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_bms_lv_cells_status_lv_cell_ntc_08_is_ot_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_bms_lv_cells_status_lv_cell_ntc_09_is_ot_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_bms_lv_cells_status_lv_cell_ntc_09_is_ot_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_bms_lv_cells_status_lv_cell_ntc_09_is_ot_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_bms_lv_cells_status_lv_cell_ntc_10_is_ot_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_bms_lv_cells_status_lv_cell_ntc_10_is_ot_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_bms_lv_cells_status_lv_cell_ntc_10_is_ot_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_bms_lv_cells_status_lv_cell_ntc_11_is_ot_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_bms_lv_cells_status_lv_cell_ntc_11_is_ot_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_bms_lv_cells_status_lv_cell_ntc_11_is_ot_is_in_range(uint8_t value);

/**
 * Pack message BMS_LV__status.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int mcb_bms_lv_status_pack(
    uint8_t *dst_p,
    const struct mcb_bms_lv_status_t *src_p,
    size_t size);

/**
 * Unpack message BMS_LV__status.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int mcb_bms_lv_status_unpack(
    struct mcb_bms_lv_status_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from BMS_LV__status.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int mcb_bms_lv_status_init(struct mcb_bms_lv_status_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_bms_lv_status_lv_relay_is_closed_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_bms_lv_status_lv_relay_is_closed_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_bms_lv_status_lv_relay_is_closed_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_bms_lv_status_lv_relay_is_relay_override_on_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_bms_lv_status_lv_relay_is_relay_override_on_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_bms_lv_status_lv_relay_is_relay_override_on_is_in_range(uint8_t value);

/**
 * Pack message BMS_LV__lvCellVoltage0.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int mcb_bms_lv_lv_cell_voltage0_pack(
    uint8_t *dst_p,
    const struct mcb_bms_lv_lv_cell_voltage0_t *src_p,
    size_t size);

/**
 * Unpack message BMS_LV__lvCellVoltage0.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int mcb_bms_lv_lv_cell_voltage0_unpack(
    struct mcb_bms_lv_lv_cell_voltage0_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from BMS_LV__lvCellVoltage0.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int mcb_bms_lv_lv_cell_voltage0_init(struct mcb_bms_lv_lv_cell_voltage0_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t mcb_bms_lv_lv_cell_voltage0_lv_cell_0_voltage_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_bms_lv_lv_cell_voltage0_lv_cell_0_voltage_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_bms_lv_lv_cell_voltage0_lv_cell_0_voltage_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t mcb_bms_lv_lv_cell_voltage0_lv_cell_1_voltage_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_bms_lv_lv_cell_voltage0_lv_cell_1_voltage_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_bms_lv_lv_cell_voltage0_lv_cell_1_voltage_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t mcb_bms_lv_lv_cell_voltage0_lv_cell_2_voltage_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_bms_lv_lv_cell_voltage0_lv_cell_2_voltage_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_bms_lv_lv_cell_voltage0_lv_cell_2_voltage_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t mcb_bms_lv_lv_cell_voltage0_lv_cell_3_voltage_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_bms_lv_lv_cell_voltage0_lv_cell_3_voltage_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_bms_lv_lv_cell_voltage0_lv_cell_3_voltage_is_in_range(uint16_t value);

/**
 * Pack message BMS_LV__lvCellVoltage1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int mcb_bms_lv_lv_cell_voltage1_pack(
    uint8_t *dst_p,
    const struct mcb_bms_lv_lv_cell_voltage1_t *src_p,
    size_t size);

/**
 * Unpack message BMS_LV__lvCellVoltage1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int mcb_bms_lv_lv_cell_voltage1_unpack(
    struct mcb_bms_lv_lv_cell_voltage1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from BMS_LV__lvCellVoltage1.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int mcb_bms_lv_lv_cell_voltage1_init(struct mcb_bms_lv_lv_cell_voltage1_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t mcb_bms_lv_lv_cell_voltage1_lv_cell_4_voltage_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_bms_lv_lv_cell_voltage1_lv_cell_4_voltage_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_bms_lv_lv_cell_voltage1_lv_cell_4_voltage_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t mcb_bms_lv_lv_cell_voltage1_lv_cell_5_voltage_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_bms_lv_lv_cell_voltage1_lv_cell_5_voltage_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_bms_lv_lv_cell_voltage1_lv_cell_5_voltage_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t mcb_bms_lv_lv_cell_voltage1_lv_cell_6_voltage_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_bms_lv_lv_cell_voltage1_lv_cell_6_voltage_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_bms_lv_lv_cell_voltage1_lv_cell_6_voltage_is_in_range(uint16_t value);

/**
 * Pack message BMS_LV__hello.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int mcb_bms_lv_hello_pack(
    uint8_t *dst_p,
    const struct mcb_bms_lv_hello_t *src_p,
    size_t size);

/**
 * Unpack message BMS_LV__hello.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int mcb_bms_lv_hello_unpack(
    struct mcb_bms_lv_hello_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from BMS_LV__hello.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int mcb_bms_lv_hello_init(struct mcb_bms_lv_hello_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_bms_lv_hello_fw_major_version_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_bms_lv_hello_fw_major_version_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_bms_lv_hello_fw_major_version_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_bms_lv_hello_fw_minor_version_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_bms_lv_hello_fw_minor_version_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_bms_lv_hello_fw_minor_version_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_bms_lv_hello_fw_patch_version_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_bms_lv_hello_fw_patch_version_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_bms_lv_hello_fw_patch_version_is_in_range(uint8_t value);

/**
 * Pack message BMS_LV__lvCellNTCResistance0.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int mcb_bms_lv_lv_cell_ntc_resistance0_pack(
    uint8_t *dst_p,
    const struct mcb_bms_lv_lv_cell_ntc_resistance0_t *src_p,
    size_t size);

/**
 * Unpack message BMS_LV__lvCellNTCResistance0.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int mcb_bms_lv_lv_cell_ntc_resistance0_unpack(
    struct mcb_bms_lv_lv_cell_ntc_resistance0_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from BMS_LV__lvCellNTCResistance0.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int mcb_bms_lv_lv_cell_ntc_resistance0_init(struct mcb_bms_lv_lv_cell_ntc_resistance0_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t mcb_bms_lv_lv_cell_ntc_resistance0_lv_cell_ntc_00_resistance_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_bms_lv_lv_cell_ntc_resistance0_lv_cell_ntc_00_resistance_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_bms_lv_lv_cell_ntc_resistance0_lv_cell_ntc_00_resistance_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t mcb_bms_lv_lv_cell_ntc_resistance0_lv_cell_ntc_01_resistance_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_bms_lv_lv_cell_ntc_resistance0_lv_cell_ntc_01_resistance_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_bms_lv_lv_cell_ntc_resistance0_lv_cell_ntc_01_resistance_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t mcb_bms_lv_lv_cell_ntc_resistance0_lv_cell_ntc_02_resistance_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_bms_lv_lv_cell_ntc_resistance0_lv_cell_ntc_02_resistance_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_bms_lv_lv_cell_ntc_resistance0_lv_cell_ntc_02_resistance_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t mcb_bms_lv_lv_cell_ntc_resistance0_lv_cell_ntc_03_resistance_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_bms_lv_lv_cell_ntc_resistance0_lv_cell_ntc_03_resistance_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_bms_lv_lv_cell_ntc_resistance0_lv_cell_ntc_03_resistance_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t mcb_bms_lv_lv_cell_ntc_resistance0_lv_cell_ntc_04_resistance_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_bms_lv_lv_cell_ntc_resistance0_lv_cell_ntc_04_resistance_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_bms_lv_lv_cell_ntc_resistance0_lv_cell_ntc_04_resistance_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t mcb_bms_lv_lv_cell_ntc_resistance0_lv_cell_ntc_05_resistance_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_bms_lv_lv_cell_ntc_resistance0_lv_cell_ntc_05_resistance_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_bms_lv_lv_cell_ntc_resistance0_lv_cell_ntc_05_resistance_is_in_range(uint16_t value);

/**
 * Pack message BMS_LV__lvCellNTCResistance1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int mcb_bms_lv_lv_cell_ntc_resistance1_pack(
    uint8_t *dst_p,
    const struct mcb_bms_lv_lv_cell_ntc_resistance1_t *src_p,
    size_t size);

/**
 * Unpack message BMS_LV__lvCellNTCResistance1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int mcb_bms_lv_lv_cell_ntc_resistance1_unpack(
    struct mcb_bms_lv_lv_cell_ntc_resistance1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from BMS_LV__lvCellNTCResistance1.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int mcb_bms_lv_lv_cell_ntc_resistance1_init(struct mcb_bms_lv_lv_cell_ntc_resistance1_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t mcb_bms_lv_lv_cell_ntc_resistance1_lv_cell_ntc_06_resistance_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_bms_lv_lv_cell_ntc_resistance1_lv_cell_ntc_06_resistance_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_bms_lv_lv_cell_ntc_resistance1_lv_cell_ntc_06_resistance_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t mcb_bms_lv_lv_cell_ntc_resistance1_lv_cell_ntc_07_resistance_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_bms_lv_lv_cell_ntc_resistance1_lv_cell_ntc_07_resistance_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_bms_lv_lv_cell_ntc_resistance1_lv_cell_ntc_07_resistance_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t mcb_bms_lv_lv_cell_ntc_resistance1_lv_cell_ntc_08_resistance_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_bms_lv_lv_cell_ntc_resistance1_lv_cell_ntc_08_resistance_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_bms_lv_lv_cell_ntc_resistance1_lv_cell_ntc_08_resistance_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t mcb_bms_lv_lv_cell_ntc_resistance1_lv_cell_ntc_09_resistance_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_bms_lv_lv_cell_ntc_resistance1_lv_cell_ntc_09_resistance_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_bms_lv_lv_cell_ntc_resistance1_lv_cell_ntc_09_resistance_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t mcb_bms_lv_lv_cell_ntc_resistance1_lv_cell_ntc_10_resistance_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_bms_lv_lv_cell_ntc_resistance1_lv_cell_ntc_10_resistance_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_bms_lv_lv_cell_ntc_resistance1_lv_cell_ntc_10_resistance_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t mcb_bms_lv_lv_cell_ntc_resistance1_lv_cell_ntc_11_resistance_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_bms_lv_lv_cell_ntc_resistance1_lv_cell_ntc_11_resistance_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_bms_lv_lv_cell_ntc_resistance1_lv_cell_ntc_11_resistance_is_in_range(uint16_t value);

/**
 * Pack message DASH__hmiDevicesState.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int mcb_dash_hmi_devices_state_pack(
    uint8_t *dst_p,
    const struct mcb_dash_hmi_devices_state_t *src_p,
    size_t size);

/**
 * Unpack message DASH__hmiDevicesState.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int mcb_dash_hmi_devices_state_unpack(
    struct mcb_dash_hmi_devices_state_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from DASH__hmiDevicesState.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int mcb_dash_hmi_devices_state_init(struct mcb_dash_hmi_devices_state_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_dash_hmi_devices_state_btn_1_is_pressed_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_dash_hmi_devices_state_btn_1_is_pressed_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_dash_hmi_devices_state_btn_1_is_pressed_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_dash_hmi_devices_state_btn_2_is_pressed_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_dash_hmi_devices_state_btn_2_is_pressed_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_dash_hmi_devices_state_btn_2_is_pressed_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_dash_hmi_devices_state_btn_3_is_pressed_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_dash_hmi_devices_state_btn_3_is_pressed_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_dash_hmi_devices_state_btn_3_is_pressed_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_dash_hmi_devices_state_btn_4_is_pressed_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_dash_hmi_devices_state_btn_4_is_pressed_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_dash_hmi_devices_state_btn_4_is_pressed_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_dash_hmi_devices_state_btn_5_is_pressed_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_dash_hmi_devices_state_btn_5_is_pressed_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_dash_hmi_devices_state_btn_5_is_pressed_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_dash_hmi_devices_state_rot_sw_1_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_dash_hmi_devices_state_rot_sw_1_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_dash_hmi_devices_state_rot_sw_1_state_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_dash_hmi_devices_state_rot_sw_2_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_dash_hmi_devices_state_rot_sw_2_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_dash_hmi_devices_state_rot_sw_2_state_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_dash_hmi_devices_state_rot_sw_3_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_dash_hmi_devices_state_rot_sw_3_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_dash_hmi_devices_state_rot_sw_3_state_is_in_range(uint8_t value);

/**
 * Pack message DASH__xcpTx.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int mcb_dash_xcp_tx_pack(
    uint8_t *dst_p,
    const struct mcb_dash_xcp_tx_t *src_p,
    size_t size);

/**
 * Unpack message DASH__xcpTx.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int mcb_dash_xcp_tx_unpack(
    struct mcb_dash_xcp_tx_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from DASH__xcpTx.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int mcb_dash_xcp_tx_init(struct mcb_dash_xcp_tx_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint64_t mcb_dash_xcp_tx_xcp_payload_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_dash_xcp_tx_xcp_payload_decode(uint64_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_dash_xcp_tx_xcp_payload_is_in_range(uint64_t value);

/**
 * Pack message DASH__peripheralsStatus.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int mcb_dash_peripherals_status_pack(
    uint8_t *dst_p,
    const struct mcb_dash_peripherals_status_t *src_p,
    size_t size);

/**
 * Unpack message DASH__peripheralsStatus.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int mcb_dash_peripherals_status_unpack(
    struct mcb_dash_peripherals_status_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from DASH__peripheralsStatus.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int mcb_dash_peripherals_status_init(struct mcb_dash_peripherals_status_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_dash_peripherals_status_tsac_fan_pwm_duty_cycle_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_dash_peripherals_status_tsac_fan_pwm_duty_cycle_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_dash_peripherals_status_tsac_fan_pwm_duty_cycle_status_is_in_range(uint8_t value);

/**
 * Pack message DASH__hello.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int mcb_dash_hello_pack(
    uint8_t *dst_p,
    const struct mcb_dash_hello_t *src_p,
    size_t size);

/**
 * Unpack message DASH__hello.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int mcb_dash_hello_unpack(
    struct mcb_dash_hello_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from DASH__hello.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int mcb_dash_hello_init(struct mcb_dash_hello_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_dash_hello_fw_major_version_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_dash_hello_fw_major_version_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_dash_hello_fw_major_version_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_dash_hello_fw_minor_version_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_dash_hello_fw_minor_version_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_dash_hello_fw_minor_version_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_dash_hello_fw_patch_version_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_dash_hello_fw_patch_version_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_dash_hello_fw_patch_version_is_in_range(uint8_t value);

/**
 * Pack message DASH__appsRangeLimits.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int mcb_dash_apps_range_limits_pack(
    uint8_t *dst_p,
    const struct mcb_dash_apps_range_limits_t *src_p,
    size_t size);

/**
 * Unpack message DASH__appsRangeLimits.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int mcb_dash_apps_range_limits_unpack(
    struct mcb_dash_apps_range_limits_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from DASH__appsRangeLimits.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int mcb_dash_apps_range_limits_init(struct mcb_dash_apps_range_limits_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t mcb_dash_apps_range_limits_apps_0_voltage_range_min_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_dash_apps_range_limits_apps_0_voltage_range_min_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_dash_apps_range_limits_apps_0_voltage_range_min_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t mcb_dash_apps_range_limits_apps_0_voltage_range_max_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_dash_apps_range_limits_apps_0_voltage_range_max_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_dash_apps_range_limits_apps_0_voltage_range_max_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t mcb_dash_apps_range_limits_apps_1_voltage_range_min_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_dash_apps_range_limits_apps_1_voltage_range_min_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_dash_apps_range_limits_apps_1_voltage_range_min_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t mcb_dash_apps_range_limits_apps_1_voltage_range_max_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_dash_apps_range_limits_apps_1_voltage_range_max_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_dash_apps_range_limits_apps_1_voltage_range_max_is_in_range(uint16_t value);

/**
 * Pack message DASH__carCommands.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int mcb_dash_car_commands_pack(
    uint8_t *dst_p,
    const struct mcb_dash_car_commands_t *src_p,
    size_t size);

/**
 * Unpack message DASH__carCommands.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int mcb_dash_car_commands_unpack(
    struct mcb_dash_car_commands_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from DASH__carCommands.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int mcb_dash_car_commands_init(struct mcb_dash_car_commands_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t mcb_dash_car_commands_bms_lv_diag_pwd_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_dash_car_commands_bms_lv_diag_pwd_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_dash_car_commands_bms_lv_diag_pwd_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_dash_car_commands_lv_relay_override_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_dash_car_commands_lv_relay_override_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_dash_car_commands_lv_relay_override_state_is_in_range(uint8_t value);

/**
 * Pack message DIAG_TOOL__xcpTxBMS_LV.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int mcb_diag_tool_xcp_tx_bms_lv_pack(
    uint8_t *dst_p,
    const struct mcb_diag_tool_xcp_tx_bms_lv_t *src_p,
    size_t size);

/**
 * Unpack message DIAG_TOOL__xcpTxBMS_LV.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int mcb_diag_tool_xcp_tx_bms_lv_unpack(
    struct mcb_diag_tool_xcp_tx_bms_lv_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from DIAG_TOOL__xcpTxBMS_LV.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int mcb_diag_tool_xcp_tx_bms_lv_init(struct mcb_diag_tool_xcp_tx_bms_lv_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint64_t mcb_diag_tool_xcp_tx_bms_lv_xcp_payload_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_diag_tool_xcp_tx_bms_lv_xcp_payload_decode(uint64_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_diag_tool_xcp_tx_bms_lv_xcp_payload_is_in_range(uint64_t value);

/**
 * Pack message DIAG_TOOL__xcpTxDASH.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int mcb_diag_tool_xcp_tx_dash_pack(
    uint8_t *dst_p,
    const struct mcb_diag_tool_xcp_tx_dash_t *src_p,
    size_t size);

/**
 * Unpack message DIAG_TOOL__xcpTxDASH.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int mcb_diag_tool_xcp_tx_dash_unpack(
    struct mcb_diag_tool_xcp_tx_dash_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from DIAG_TOOL__xcpTxDASH.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int mcb_diag_tool_xcp_tx_dash_init(struct mcb_diag_tool_xcp_tx_dash_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint64_t mcb_diag_tool_xcp_tx_dash_xcp_payload_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_diag_tool_xcp_tx_dash_xcp_payload_decode(uint64_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_diag_tool_xcp_tx_dash_xcp_payload_is_in_range(uint64_t value);

/**
 * Pack message DIAG_TOOL__xcpTxSB_REAR.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int mcb_diag_tool_xcp_tx_sb_rear_pack(
    uint8_t *dst_p,
    const struct mcb_diag_tool_xcp_tx_sb_rear_t *src_p,
    size_t size);

/**
 * Unpack message DIAG_TOOL__xcpTxSB_REAR.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int mcb_diag_tool_xcp_tx_sb_rear_unpack(
    struct mcb_diag_tool_xcp_tx_sb_rear_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from DIAG_TOOL__xcpTxSB_REAR.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int mcb_diag_tool_xcp_tx_sb_rear_init(struct mcb_diag_tool_xcp_tx_sb_rear_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint64_t mcb_diag_tool_xcp_tx_sb_rear_xcp_payload_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_diag_tool_xcp_tx_sb_rear_xcp_payload_decode(uint64_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_diag_tool_xcp_tx_sb_rear_xcp_payload_is_in_range(uint64_t value);

/**
 * Pack message DIAG_TOOL__xcpTxSB_FRONT.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int mcb_diag_tool_xcp_tx_sb_front_pack(
    uint8_t *dst_p,
    const struct mcb_diag_tool_xcp_tx_sb_front_t *src_p,
    size_t size);

/**
 * Unpack message DIAG_TOOL__xcpTxSB_FRONT.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int mcb_diag_tool_xcp_tx_sb_front_unpack(
    struct mcb_diag_tool_xcp_tx_sb_front_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from DIAG_TOOL__xcpTxSB_FRONT.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int mcb_diag_tool_xcp_tx_sb_front_init(struct mcb_diag_tool_xcp_tx_sb_front_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint64_t mcb_diag_tool_xcp_tx_sb_front_xcp_payload_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_diag_tool_xcp_tx_sb_front_xcp_payload_decode(uint64_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_diag_tool_xcp_tx_sb_front_xcp_payload_is_in_range(uint64_t value);

/**
 * Pack message DIAG_TOOL__xcpTxSCANNER.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int mcb_diag_tool_xcp_tx_scanner_pack(
    uint8_t *dst_p,
    const struct mcb_diag_tool_xcp_tx_scanner_t *src_p,
    size_t size);

/**
 * Unpack message DIAG_TOOL__xcpTxSCANNER.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int mcb_diag_tool_xcp_tx_scanner_unpack(
    struct mcb_diag_tool_xcp_tx_scanner_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from DIAG_TOOL__xcpTxSCANNER.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int mcb_diag_tool_xcp_tx_scanner_init(struct mcb_diag_tool_xcp_tx_scanner_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint64_t mcb_diag_tool_xcp_tx_scanner_xcp_payload_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_diag_tool_xcp_tx_scanner_xcp_payload_decode(uint64_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_diag_tool_xcp_tx_scanner_xcp_payload_is_in_range(uint64_t value);

/**
 * Pack message DIAG_TOOL__xcpTxTLB_BAT.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int mcb_diag_tool_xcp_tx_tlb_bat_pack(
    uint8_t *dst_p,
    const struct mcb_diag_tool_xcp_tx_tlb_bat_t *src_p,
    size_t size);

/**
 * Unpack message DIAG_TOOL__xcpTxTLB_BAT.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int mcb_diag_tool_xcp_tx_tlb_bat_unpack(
    struct mcb_diag_tool_xcp_tx_tlb_bat_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from DIAG_TOOL__xcpTxTLB_BAT.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int mcb_diag_tool_xcp_tx_tlb_bat_init(struct mcb_diag_tool_xcp_tx_tlb_bat_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint64_t mcb_diag_tool_xcp_tx_tlb_bat_xcp_payload_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_diag_tool_xcp_tx_tlb_bat_xcp_payload_decode(uint64_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_diag_tool_xcp_tx_tlb_bat_xcp_payload_is_in_range(uint64_t value);

/**
 * Pack message DSPACE__timeAndDate.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int mcb_dspace_time_and_date_pack(
    uint8_t *dst_p,
    const struct mcb_dspace_time_and_date_t *src_p,
    size_t size);

/**
 * Unpack message DSPACE__timeAndDate.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int mcb_dspace_time_and_date_unpack(
    struct mcb_dspace_time_and_date_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from DSPACE__timeAndDate.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int mcb_dspace_time_and_date_init(struct mcb_dspace_time_and_date_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_dspace_time_and_date_datetime_year_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_dspace_time_and_date_datetime_year_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_dspace_time_and_date_datetime_year_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_dspace_time_and_date_datetime_month_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_dspace_time_and_date_datetime_month_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_dspace_time_and_date_datetime_month_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_dspace_time_and_date_datetime_day_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_dspace_time_and_date_datetime_day_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_dspace_time_and_date_datetime_day_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_dspace_time_and_date_datetime_hours_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_dspace_time_and_date_datetime_hours_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_dspace_time_and_date_datetime_hours_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_dspace_time_and_date_datetime_minutes_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_dspace_time_and_date_datetime_minutes_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_dspace_time_and_date_datetime_minutes_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_dspace_time_and_date_datetime_seconds_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_dspace_time_and_date_datetime_seconds_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_dspace_time_and_date_datetime_seconds_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_dspace_time_and_date_datetime_houndres_of_a_seconds_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_dspace_time_and_date_datetime_houndres_of_a_seconds_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_dspace_time_and_date_datetime_houndres_of_a_seconds_is_in_range(uint8_t value);

/**
 * Pack message DSPACE__peripheralsCTRL.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int mcb_dspace_peripherals_ctrl_pack(
    uint8_t *dst_p,
    const struct mcb_dspace_peripherals_ctrl_t *src_p,
    size_t size);

/**
 * Unpack message DSPACE__peripheralsCTRL.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int mcb_dspace_peripherals_ctrl_unpack(
    struct mcb_dspace_peripherals_ctrl_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from DSPACE__peripheralsCTRL.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int mcb_dspace_peripherals_ctrl_init(struct mcb_dspace_peripherals_ctrl_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_dspace_peripherals_ctrl_brake_light_active_cmd_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_dspace_peripherals_ctrl_brake_light_active_cmd_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_dspace_peripherals_ctrl_brake_light_active_cmd_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_dspace_peripherals_ctrl_dash_sdc_rly_close_cmd_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_dspace_peripherals_ctrl_dash_sdc_rly_close_cmd_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_dspace_peripherals_ctrl_dash_sdc_rly_close_cmd_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_dspace_peripherals_ctrl_rad_fan_pwm_duty_cicle_ctrl_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_dspace_peripherals_ctrl_rad_fan_pwm_duty_cicle_ctrl_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_dspace_peripherals_ctrl_rad_fan_pwm_duty_cicle_ctrl_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_dspace_peripherals_ctrl_cool_pumps_speed_ctrl_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_dspace_peripherals_ctrl_cool_pumps_speed_ctrl_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_dspace_peripherals_ctrl_cool_pumps_speed_ctrl_is_in_range(uint8_t value);

/**
 * Pack message DSPACE__pwtFrontTemp.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int mcb_dspace_pwt_front_temp_pack(
    uint8_t *dst_p,
    const struct mcb_dspace_pwt_front_temp_t *src_p,
    size_t size);

/**
 * Unpack message DSPACE__pwtFrontTemp.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int mcb_dspace_pwt_front_temp_unpack(
    struct mcb_dspace_pwt_front_temp_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from DSPACE__pwtFrontTemp.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int mcb_dspace_pwt_front_temp_init(struct mcb_dspace_pwt_front_temp_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t mcb_dspace_pwt_front_temp_inverter_fl_temp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_dspace_pwt_front_temp_inverter_fl_temp_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_dspace_pwt_front_temp_inverter_fl_temp_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t mcb_dspace_pwt_front_temp_motor_fl_temp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_dspace_pwt_front_temp_motor_fl_temp_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_dspace_pwt_front_temp_motor_fl_temp_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t mcb_dspace_pwt_front_temp_inverter_fr_temp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_dspace_pwt_front_temp_inverter_fr_temp_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_dspace_pwt_front_temp_inverter_fr_temp_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t mcb_dspace_pwt_front_temp_motor_fr_temp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_dspace_pwt_front_temp_motor_fr_temp_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_dspace_pwt_front_temp_motor_fr_temp_is_in_range(uint16_t value);

/**
 * Pack message DSPACE__pwtRearTemp.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int mcb_dspace_pwt_rear_temp_pack(
    uint8_t *dst_p,
    const struct mcb_dspace_pwt_rear_temp_t *src_p,
    size_t size);

/**
 * Unpack message DSPACE__pwtRearTemp.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int mcb_dspace_pwt_rear_temp_unpack(
    struct mcb_dspace_pwt_rear_temp_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from DSPACE__pwtRearTemp.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int mcb_dspace_pwt_rear_temp_init(struct mcb_dspace_pwt_rear_temp_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t mcb_dspace_pwt_rear_temp_inverter_rl_temp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_dspace_pwt_rear_temp_inverter_rl_temp_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_dspace_pwt_rear_temp_inverter_rl_temp_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t mcb_dspace_pwt_rear_temp_motor_rl_temp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_dspace_pwt_rear_temp_motor_rl_temp_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_dspace_pwt_rear_temp_motor_rl_temp_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t mcb_dspace_pwt_rear_temp_inverter_rr_temp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_dspace_pwt_rear_temp_inverter_rr_temp_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_dspace_pwt_rear_temp_inverter_rr_temp_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t mcb_dspace_pwt_rear_temp_motor_rr_temp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_dspace_pwt_rear_temp_motor_rr_temp_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_dspace_pwt_rear_temp_motor_rr_temp_is_in_range(uint16_t value);

/**
 * Pack message DSPACE__xcpTx.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int mcb_dspace_xcp_tx_pack(
    uint8_t *dst_p,
    const struct mcb_dspace_xcp_tx_t *src_p,
    size_t size);

/**
 * Unpack message DSPACE__xcpTx.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int mcb_dspace_xcp_tx_unpack(
    struct mcb_dspace_xcp_tx_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from DSPACE__xcpTx.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int mcb_dspace_xcp_tx_init(struct mcb_dspace_xcp_tx_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint64_t mcb_dspace_xcp_tx_xcp_payload_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_dspace_xcp_tx_xcp_payload_decode(uint64_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_dspace_xcp_tx_xcp_payload_is_in_range(uint64_t value);

/**
 * Pack message DSPACE__signals.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int mcb_dspace_signals_pack(
    uint8_t *dst_p,
    const struct mcb_dspace_signals_t *src_p,
    size_t size);

/**
 * Unpack message DSPACE__signals.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int mcb_dspace_signals_unpack(
    struct mcb_dspace_signals_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from DSPACE__signals.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int mcb_dspace_signals_init(struct mcb_dspace_signals_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_dspace_signals_hvbat_soc_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_dspace_signals_hvbat_soc_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_dspace_signals_hvbat_soc_is_in_range(uint8_t value);

/**
 * Pack message DSPACE__fsmStates.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int mcb_dspace_fsm_states_pack(
    uint8_t *dst_p,
    const struct mcb_dspace_fsm_states_t *src_p,
    size_t size);

/**
 * Unpack message DSPACE__fsmStates.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int mcb_dspace_fsm_states_unpack(
    struct mcb_dspace_fsm_states_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from DSPACE__fsmStates.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int mcb_dspace_fsm_states_init(struct mcb_dspace_fsm_states_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_dspace_fsm_states_dspace_main_fsm_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_dspace_fsm_states_dspace_main_fsm_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_dspace_fsm_states_dspace_main_fsm_state_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_dspace_fsm_states_dspace_amk_inv_fl_fsm_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_dspace_fsm_states_dspace_amk_inv_fl_fsm_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_dspace_fsm_states_dspace_amk_inv_fl_fsm_state_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_dspace_fsm_states_dspace_amk_inv_fr_fsm_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_dspace_fsm_states_dspace_amk_inv_fr_fsm_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_dspace_fsm_states_dspace_amk_inv_fr_fsm_state_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_dspace_fsm_states_dspace_amk_inv_rl_fsm_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_dspace_fsm_states_dspace_amk_inv_rl_fsm_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_dspace_fsm_states_dspace_amk_inv_rl_fsm_state_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_dspace_fsm_states_dspace_amk_inv_rr_fsm_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_dspace_fsm_states_dspace_amk_inv_rr_fsm_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_dspace_fsm_states_dspace_amk_inv_rr_fsm_state_is_in_range(uint8_t value);

/**
 * Pack message DSPACE__hello.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int mcb_dspace_hello_pack(
    uint8_t *dst_p,
    const struct mcb_dspace_hello_t *src_p,
    size_t size);

/**
 * Unpack message DSPACE__hello.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int mcb_dspace_hello_unpack(
    struct mcb_dspace_hello_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from DSPACE__hello.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int mcb_dspace_hello_init(struct mcb_dspace_hello_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_dspace_hello_fw_major_version_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_dspace_hello_fw_major_version_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_dspace_hello_fw_major_version_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_dspace_hello_fw_minor_version_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_dspace_hello_fw_minor_version_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_dspace_hello_fw_minor_version_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_dspace_hello_fw_patch_version_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_dspace_hello_fw_patch_version_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_dspace_hello_fw_patch_version_is_in_range(uint8_t value);

/**
 * Pack message DSPACE__dashLedsColorRGB.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int mcb_dspace_dash_leds_color_rgb_pack(
    uint8_t *dst_p,
    const struct mcb_dspace_dash_leds_color_rgb_t *src_p,
    size_t size);

/**
 * Unpack message DSPACE__dashLedsColorRGB.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int mcb_dspace_dash_leds_color_rgb_unpack(
    struct mcb_dspace_dash_leds_color_rgb_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from DSPACE__dashLedsColorRGB.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int mcb_dspace_dash_leds_color_rgb_init(struct mcb_dspace_dash_leds_color_rgb_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_dspace_dash_leds_color_rgb_led_1_red_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_dspace_dash_leds_color_rgb_led_1_red_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_dspace_dash_leds_color_rgb_led_1_red_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_dspace_dash_leds_color_rgb_led_1_green_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_dspace_dash_leds_color_rgb_led_1_green_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_dspace_dash_leds_color_rgb_led_1_green_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_dspace_dash_leds_color_rgb_led_1_blue_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_dspace_dash_leds_color_rgb_led_1_blue_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_dspace_dash_leds_color_rgb_led_1_blue_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_dspace_dash_leds_color_rgb_led_2_red_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_dspace_dash_leds_color_rgb_led_2_red_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_dspace_dash_leds_color_rgb_led_2_red_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_dspace_dash_leds_color_rgb_led_2_green_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_dspace_dash_leds_color_rgb_led_2_green_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_dspace_dash_leds_color_rgb_led_2_green_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_dspace_dash_leds_color_rgb_led_2_blue_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_dspace_dash_leds_color_rgb_led_2_blue_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_dspace_dash_leds_color_rgb_led_2_blue_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_dspace_dash_leds_color_rgb_led_3_red_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_dspace_dash_leds_color_rgb_led_3_red_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_dspace_dash_leds_color_rgb_led_3_red_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_dspace_dash_leds_color_rgb_led_3_green_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_dspace_dash_leds_color_rgb_led_3_green_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_dspace_dash_leds_color_rgb_led_3_green_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_dspace_dash_leds_color_rgb_led_3_blue_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_dspace_dash_leds_color_rgb_led_3_blue_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_dspace_dash_leds_color_rgb_led_3_blue_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_dspace_dash_leds_color_rgb_led_4_red_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_dspace_dash_leds_color_rgb_led_4_red_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_dspace_dash_leds_color_rgb_led_4_red_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_dspace_dash_leds_color_rgb_led_4_green_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_dspace_dash_leds_color_rgb_led_4_green_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_dspace_dash_leds_color_rgb_led_4_green_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t mcb_dspace_dash_leds_color_rgb_led_4_blue_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_dspace_dash_leds_color_rgb_led_4_blue_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_dspace_dash_leds_color_rgb_led_4_blue_is_in_range(uint8_t value);

/**
 * Pack message SCANNER__xcpTx.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int mcb_scanner_xcp_tx_pack(
    uint8_t *dst_p,
    const struct mcb_scanner_xcp_tx_t *src_p,
    size_t size);

/**
 * Unpack message SCANNER__xcpTx.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int mcb_scanner_xcp_tx_unpack(
    struct mcb_scanner_xcp_tx_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Init message fields to default values from SCANNER__xcpTx.
 *
 * @param[in] msg_p Message to init.
 *
 * @return zero(0) on success or (-1) in case of nullptr argument.
 */
int mcb_scanner_xcp_tx_init(struct mcb_scanner_xcp_tx_t *msg_p);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint64_t mcb_scanner_xcp_tx_xcp_payload_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double mcb_scanner_xcp_tx_xcp_payload_decode(uint64_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool mcb_scanner_xcp_tx_xcp_payload_is_in_range(uint64_t value);


#ifdef __cplusplus
}
#endif

#endif
